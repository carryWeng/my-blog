#### 1.webpack

Webpack是一个现代化的静态模块打包工具，它可以将多个模块打包成一个或多个文件，以便于在浏览器中使用。Webpack的基本配置包括以下几个方面：



1. 入口(entry)：指定Webpack打包的入口文件，可以是单个文件或多个文件。
2. 输出(output)：指定Webpack打包后生成的文件的输出路径和文件名，可以是单个文件或多个文件。
3. 模式(mode)：指定Webpack的打包模式，可以是开发模式(development)或生产模式(production)。
4. 加载器(loaders)：Webpack可以通过加载器来处理非JavaScript文件，例如CSS、图片、字体等文件。加载器可以将这些文件转换为JavaScript模块，以便于Webpack进行打包。
5. 插件(plugins)：Webpack的插件可以用于执行各种任务，例如压缩代码、拷贝文件、生成HTML文件等。
6. 解析(resolve)：Webpack可以通过解析器来解析各种类型的模块，例如JavaScript、CSS、图片等文件。
7. 开发服务器(devServer)：Webpack提供了一个开发服务器，可以在开发过程中实时预览打包后的结果。

一个基本的Webpack配置文件如下所示：

```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  mode: 'development',
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: ['file-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ],
  resolve: {
    extensions: ['.js', '.json']
  },
  devServer: {
    contentBase: './dist',
    port: 8080
  }
};
```



以上是一个基本的Webpack配置，具体的配置项可以根据实际需求进行调整。



#### 2.判断类型的方法

在JavaScript中，判断一个数据的类型有以下几种方法：
1. typeof运算符：可以判断数据类型，例如：
   ```javascript
   typeof 123; // "number"
   typeof "hello"; // "string"
   typeof true; // "boolean"
   typeof undefined; // "undefined"
   typeof null; // "object"
   typeof {}; // "object"
   typeof []; // "object"
   typeof function(){}; // "function"
   ```
   优点：简单易用，对于基本数据类型可以准确判断。

   缺点：对于null和数组等数据类型，typeof会返回"object"，对于函数类型会返回"function"，不够准确。
2. instanceof运算符：可以判断一个对象是否是某个构造函数的实例，例如：
   ```javascript
   const arr = [1, 2, 3];
   arr instanceof Array; // true
   ```
   优点：可以判断对象的具体类型。

   缺点：无法判断基本数据类型，如果对象的原型链被修改，可能会出现误判。
3. Object.prototype.toString方法：可以返回一个对象的类型字符串，例如：

   ```javascript
   const obj = {};
   Object.prototype.toString.call(obj); // "[object Object]"
   ```

   优点：可以准确地判断对象类型，不受原型链影响。

   缺点：对于基本数据类型，需要先将其包装成对象才能使用该方法。
4. constructor属性：可以返回一个对象的构造函数，例如：

   ```javascript
   const str = "hello";
   str.constructor === String; // true
   ```

   优点：可以准确地判断对象类型，不受原型链影响。

   缺点：对于基本数据类型，需要先将其包装成对象才能使用该方法，同时constructor属性可能会被修改。

综上所述，不同的判断方法各有优缺点，需要根据具体的场景和需求，选择合适的方法。在判断对象类型时，建议使用Object.prototype.toString方法或constructor属性，而在判断基本数据类型时，建议使用typeof运算符。

#### 3.node环境和浏览器环境的区别

Node环境和浏览器环境是两种不同的JavaScript运行环境，它们有以下区别：
1. 执行环境不同：Node运行在服务端，而浏览器运行在客户端。
2. 全局对象不同：Node中的全局对象是global，而浏览器中的全局对象是window。
3. 核心模块不同：Node提供了一些核心模块，如fs、http、path等，而浏览器没有这些模块。
4. DOM和BOM对象不同：浏览器提供了DOM和BOM对象，如document、window、location等，而Node没有这些对象。
5. 模块系统不同：Node使用CommonJS规范实现模块化，而浏览器使用ES6的模块化规范或AMD/CMD规范实现模块化。
6. 文件操作不同：Node可以进行文件的读写操作，而浏览器不支持文件的读写。
7. 网络请求不同：Node可以进行网络请求，如http、https等，而浏览器也可以进行网络请求，但需要遵循同源策略。
8. 性能不同：Node在处理I/O密集型任务时性能表现优异，而在计算密集型任务时性能表现较差；而浏览器在处理计算密集型任务时性能表现较好，而在I/O密集型任务时性能表现较差。

综上所述，Node环境和浏览器环境有很多不同之处，开发者需要根据具体的场景选择合适的环境。

#### 4.HTML5和CSS3新特性

HTML5和CSS3是Web前端开发中的两个重要技术标准，它们引入了很多新的特性和功能，以下是它们的一些新特性：

HTML5新特性：
1. 新的语义化标签，如`<article>`、`<section>`、`<nav>`、`<header>`、`<footer>`等，可以更好地描述页面结构和内容。
2. 表单控件增强，如日期选择器、颜色选择器、搜索框自动完成功能等，可以提升用户体验。
3. 增强的多媒体支持，如`<video>`、`<audio>`等标签，可以直接在网页中嵌入视频、音频等多媒体内容。
4. 新的API，如Canvas、Web Storage、Web Worker、Web Socket等，为Web应用提供了更多的功能和性能优化。
5. 支持离线应用，通过应用缓存和本地存储等技术，可以让Web应用在离线状态下继续运行。

CSS3新特性：
1. 强大的选择器，如属性选择器、伪类选择器、伪元素选择器等，可以更精确地选择元素。
2. 增强的布局方式，如Flexbox、Grid等，可以更方便地实现复杂的布局效果。
3. 动画和过渡效果，如transform、transition、animation等属性，可以为元素添加动态效果。
4. 字体和文字处理，如@font-face、text-shadow、word-wrap等属性，可以更好地控制字体和文字的样式。
5. 响应式设计，通过媒体查询等技术，可以让网页在不同设备上呈现不同的布局和样式，提升用户体验。

#### 5.ES6新特性

ES6（ECMAScript 2015）是JavaScript的一个重要版本，引入了很多新的语言特性和API，以下是ES6的一些新特性：

1. let和const关键字：用于声明块级作用域的变量和常量。 
2. 箭头函数：简化函数的定义和使用。 
3. 模板字符串：用于更方便地拼接字符串。 
4.  解构赋值：可以从数组或对象中提取值，赋值给变量。 
5.  对象字面量增强：可以更方便地定义对象和方法。
6.  class关键字：用于定义类和对象，实现面向对象编程。 
7.  Promise对象：用于处理异步操作，避免回调地狱。 
8. 模块化：引入了import和export关键字，实现了模块化开发。 
9.  for...of循环：用于遍历数组、字符串等可迭代对象。 
10. Symbol类型：用于创建唯一的值，可以用于对象的属性名。
11.  Set和Map数据结构：用于存储一组不重复的值和键值对。 
12. Proxy对象：用于创建一个代理对象，可以拦截对象的操作。 
13.  async/await关键字：用于处理异步操作，更加简洁明了。 



#### 6.CSS过渡(Transition)和动画(Animation)区别

CSS过渡(Transition)和动画(Animation)都是用于为HTML元素添加动态效果的CSS属性，它们的区别如下： 

1. 触发时机不同：CSS过渡是在CSS属性值发生变化时触发，而CSS动画是在CSS属性值发生变化时或通过JavaScript触发时触发。 
2.  实现方式不同：CSS过渡是通过在CSS属性上添加过渡效果，实现属性值的平滑过渡，而CSS动画是通过在CSS属性上添加关键帧，实现属性值的逐帧动画。 
3. 控制方式不同：CSS过渡的动画效果是由浏览器自动控制的，无法精确控制动画的开始



CSS 过渡和动画都是用来实现网页元素的动态效果，但它们的实现方式和效果略有不同。

CSS 过渡是指在一个 CSS 属性值发生变化时，元素从旧值平滑地过渡到新值的效果。过渡通常是在元素状态发生变化时触发，比如鼠标悬停、点击等。过渡更适合实现简单的状态变化效果。

CSS 动画则是指通过连续的关键帧来实现元素的动态效果。在动画中，我们可以定义多个关键帧，每个关键帧对应一个 CSS 属性值的设置。动画更适合实现复杂的动态效果。

需要注意的是，CSS 过渡和动画都可以通过设置不同的参数来控制动态效果的细节，比如过渡时间、速度曲线、延迟时间等。

#### 7.VueX 

Vuex的核心点包括：
1.State管理：用于存储和更新应用程序的状态；
2.Getters：用于计算state值的计算属性；
3.Mutations：用于更改state的同步函数；
4.Actions：用于处理异步操作的函数；
5.Modules：用于将store分割成模块的功能



--

##### 组件中使用state数据的方法

###### 1.this.$store.state.全局数据名称

###### 2.就是下面的 mapState的方式

--

调用state的mutation里面的方法

如果您不想使用 `mapMutations` 函数，您也可以直接在组件中使用 `this.$store.commit()` 方法来调用 mutation。

以下是一个示例：

```js
export default {
  methods: {
    handleLogin() {
      // 调用 login mutation
      this.$store.commit('login')
    }
  }
}
```

示例中，我们使用 `this.$store.commit()` 方法来调用 `login` mutation。

如果您需要将参数传递给 mutation，也可以在调用 mutation 时传递一个参数。例如：

```js
export default {
  methods: {
    handleLogin(username) {
      // 调用 setUsername mutation，并传递一个参数
      this.$store.commit('setUsername', username)
    }
  }
}
```

在上面的示例中，我们使用 `this.$store.commit()` 方法来调用 `setUsername` mutation，并在调用 mutation 时传递一个参数 `username`。在 mutation 中，您可以通过第二个参数来接收该参数：

```js
mutations: {
  setUsername(state, username) {
    state.username = username
  }
}
```

--



在Vue项目中，可以通过`mapState`和`mapActions`辅助函数将Vuex中的状态和方法映射到组件的`data`和`methods`中。

`mapState`函数可以将Vuex中的状态映射到组件的`data`中，示例如下：

```js
import { mapState } from 'vuex'

export default {
  computed: {
    ...mapState({
      count: state => state.count
    })
  }
}
```

在上面的示例中，`mapState`函数将Vuex中的`count`状态映射到了组件的`count`属性中。

`mapActions`函数可以将Vuex中的方法映射到组件的`methods`中，示例如下：

```js
import { mapActions } from 'vuex'

export default {
  methods: {
    ...mapActions([
      'increment',
      'decrement'
    ])
  }
}
```

在上面的示例中，`mapActions`函数将Vuex中的`increment`和`decrement`方法映射到了组件的`increment`和`decrement`方法中。

使用这些辅助函数可以使得在组件中使用Vuex更加方便和简洁。



---

如果是模块化的

在一个大型的 Vue.js 应用程序中，一个单一的 Vuex store 可能会变得非常大且难以维护。为了解决这个问题，Vuex 提供了模块化机制，允许将 store 拆分为多个模块，每个模块都拥有自己的 state、mutations、actions、getters 等。

以下是一个简单的示例：

```js
// 在 store.js 文件中引入 vuex 和需要使用的模块
import Vue from 'vue'
import Vuex from 'vuex'
import user from './modules/user'
import cart from './modules/cart'

Vue.use(Vuex)

// 创建 Vuex store
const store = new Vuex.Store({
  modules: {
    // 在 modules 选项中注册模块
    user,
    cart
  }
})

export default store
```

在上面的示例中，我们在 `modules` 选项中注册了两个模块：`user` 和 `cart`。每个模块都是一个包含 state、mutations、actions、getters 等的对象。

以下是一个简单的模块示例：

```js
// 在 user.js 文件中定义 user 模块
const user = {
  state: {
    // 状态
  },
  mutations: {
    // 修改状态的方法
  },
  actions: {
    // 用于异步操作的方法
  },
  getters: {
    // 计算属性
  }
}

export default user
```

在上面的示例中，我们定义了一个名为 `user` 的模块，其中包含 state、mutations、actions、getters 等。在 `store.js` 文件中，我们使用 `import` 语句将该模块导入，并在 `modules` 选项中注册。

要在组件中访问模块中的 state、mutations、actions、getters 等，您需要在组件中使用命名空间。例如，要访问 `user` 模块中的 `state`，您可以使用以下代码：

```js
export default {
  computed: {
    // 使用命名空间访问 user 模块中的 state
    ...mapState('user', {
      username: state => state.username
    })
  }
}
```

在上面的示例中，我们使用 `mapState` 函数将 `user` 模块中的 `username` 映射到组件的 `computed` 中，并使用命名空间 `'user'` 来访问该模块。

类似地，要访问模块中的 mutations、actions、getters 等，您可以使用 `mapMutations`、`mapActions`、`mapGetters` 函数，并指定模块的命名空间。例如：

```js
// 在组件中引入 mapMutations 函数和需要使用的 mutation
import { mapMutations } from 'vuex'

export default {
  methods: {
    // 使用命名空间访问 user 模块中的 login mutation
    ...mapMutations('user', ['login']),
    handleLogin() {
      // 调用 user 模块中的 login mutation
      this.login()
    }
  }
}
```





---



---



geeter

---



###### action跟mutation区别

action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。

action 可以包含任意异步操作。mutation只能是同步操作。

提交方式不同，action 是用`this.$store.dispatch('ACTION_NAME',data)`来提交。mutation是用`this.$store.commit('SET_NUMBER',10)`来提交。

接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了

```js
{
    state,      // 等同于 `store.state`，若在模块中则为局部状态
    rootState,  // 等同于 `store.state`，只存在于模块中
    commit,     // 等同于 `store.commit`
    dispatch,   // 等同于 `store.dispatch`
    getters,    // 等同于 `store.getters`
    rootGetters // 等同于 `store.getters`，只存在于模块中
}
```



###### 调用actions里面的方法不使用mapActions的情况

如果你不想使用 `mapActions` ，你可以直接在组件中使用 `this.$store.dispatch('actionName')` 来触发一个 action。例如：

```vue
methods: {
  increment() {
    this.$store.dispatch('increment')
  },
  decrement() {
    this.$store.dispatch('decrement')
  }
}
```

这里的 `increment` 和 `decrement` 是在 Vuex store 中定义的 actions。你可以根据自己的需要来定义它们。

在 Vuex 中，actions 是用来处理异步操作的。它们可以包含任意异步操作，例如 API 请求、定时器等等。一个 action 可以触发多个 mutation，也可以触发其他的 action。

一个 action 方法接收一个与 store 实例具有相同方法和属性的对象作为参数，我们通常将其称为 `context` 对象。通过 context 对象，我们可以调用 state、commit、dispatch 等方法。

下面是一个简单的 actions 示例：

```js
const actions = {
  incrementAsync ({ commit }) {
    setTimeout(() => {
      commit('increment')
    }, 1000)
  }
}
```

在这个示例中，我们定义了一个名为 `incrementAsync` 的 action，它接收一个 context 对象作为参数。我们使用 `setTimeout` 函数模拟了一个异步操作，然后在 1 秒钟后调用了 `commit` 方法来触发一个名为 `increment` 的 mutation。

在组件中，我们可以使用 `dispatch` 方法来触发一个 action：

```js
this.$store.dispatch('incrementAsync')
```

这样就会触发 `incrementAsync` action，然后在 1 秒钟后触发 `increment` mutation。



vuex做数据持久化








#### 8.null和undefined的区别

在JavaScript中，null和undefined都表示没有值，但它们的含义稍有不同。

- undefined表示一个变量已经声明但尚未被赋值，或者一个属性存在于对象中，但没有给它赋值。

  例如：

   ```js
  let a; 
  console.log(a); // 输出undefined
  const obj = {}; 
  console.log(obj.prop); // 输出undefined
   ```

  

-   null表示一个变量或属性已经被显式地赋值为null，表示它没有值。

  例如：

   ```js
  let b = null;
  console.log(b); // 输出null 
  const obj = { prop: null }; 
  console.log(obj.prop); // 输出null
   ```

  总的来说，undefined表示缺少值，而null表示有一个值，但是这个值是空的。

在 JavaScript 中，null 和 undefined 都表示没有值，但它们有一些细微的区别。

null 表示一个空对象指针，它用于表示一个变量被赋值为一个空对象，或者用于表示函数返回的是一个空对象。如果一个变量被赋值为 null，那么它的值为 null，类型为 object。

undefined 表示一个未定义的值，它用于表示一个变量未被赋值，或者一个对象没有被赋值的属性。如果一个变量未被赋值，那么它的值和类型都是 undefined。

在使用条件语句时，null 和 undefined 的行为也有所不同。当一个变量的值为 null 时，它被认为是一个空对象，因此在条件语句中会被转换为 false。而当一个变量的值为 undefined 时，在条件语句中会被转换为 false，但是在进行数学运算时会被转换为 NaN。

总的来说，null 表示一个空对象指针，undefined 表示一个未定义的值。在使用条件语句时，null 会被转换为 false，而 undefined 在条件语句和数学运算中都会被转换为 false 或 NaN。

#### 9.动态路由做权限管理

在Vue.js项目中，可以使用动态路由来实现权限管理。具体来说，可以根据用户的角色或权限动态生成路由，然后根据用户的登录状态和角色来决定显示哪些路由。

下面是一个简单的示例，演示如何在Vue.js中使用动态路由来实现权限管理：

首先，在路由配置中定义需要进行权限控制的路由：

```js
const routes = [
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: Dashboard,
    meta: { requiresAuth: true, roles: ['admin', 'user'] }
  },
  {
    path: '/settings',
    name: 'Settings',
    component: Settings,
    meta: { requiresAuth: true, roles: ['admin'] }
  },
  {
    path: '/login',
    name: 'Login',
    component: Login
  }
]
```

在上面的代码中，我们定义了三个路由：`Dashboard`、`Settings`和`Login`。其中，`Dashboard`和`Settings`需要进行权限控制，只有登录用户且角色为`admin`或`user`才能访问；而`Login`路由不需要进行权限控制。

接着，在Vue Router中使用路由守卫来实现权限控制：

```js
router.beforeEach((to, from, next) => {
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth)
  if (requiresAuth) {
    const isAuthenticated = store.getters.isAuthenticated
    if (!isAuthenticated) {
      next('/login')
    } else {
      const roles = to.meta.roles
      const userRole = store.getters.getUserRole
      if (!roles || roles.includes(userRole)) {
        next()
      } else {
        next('/dashboard')
      }
    }
  } else {
    next()
  }
})
```



在上面的代码中，我们使用了`beforeEach`路由守卫，对需要进行权限控制的路由进行拦截。首先，判断当前路由是否需要进行权限控制，如果需要，则判断用户是否已登录，如果未登录，则跳转到登录页面；如果已登录，则判断用户角色是否有权限访问该路由，如果有权限，则放行；否则，跳转到默认页面。如果当前路由不需要进行权限控制，则直接放行。

最后，在store中定义获取用户角色和登录状态的getter：

```js
const store = new Vuex.Store({
  state: {
    userRole: null,
    isAuthenticated: false
  },
  getters: {
    getUserRole: state => state.userRole,
    isAuthenticated: state => state.isAuthenticated
  },
  mutations: {
    setUserRole(state, role) {
      state.userRole = role
    },
    setIsAuthenticated(state, isAuthenticated) {
      state.isAuthenticated = isAuthenticated
    }
  }
})
```

在上面的代码中，我们使用了Vuex来管理应用程序的状态，包括用户角色和登录状态。在需要进行权限控制的路由中，可以使用`getters`来获取用户角色和登录状态，并根据这些信息来决定是否放行路由。

#### 10.HTTP常见状态码

HTTP（超文本传输协议）是一种用于传输数据的协议，常见的 HTTP 状态码有以下几种：
1. 1xx（信息性状态码）：表示请求已经被接收，正在处理中。
2. 2xx（成功状态码）：表示请求已经被成功接收、理解和处理。
    - 200 OK：表示请求已经成功处理。
    - 201 Created：表示请求已经成功处理，并创建了新的资源。
    - 204 No Content：表示请求已经成功处理，但是没有返回任何内容。
3. 3xx（重定向状态码）：表示客户端需要执行某些额外的操作才能完成请求。
    - 301 Moved Permanently：表示请求的资源已经永久移动到新的位置。
    - 302 Found：表示请求的资源已经暂时移动到新的位置。
    - 304 Not Modified：表示客户端可以使用缓存的版本。
4. 4xx（客户端错误状态码）：表示客户端发送的请求有错误。
    - 400 Bad Request：表示请求有语法错误或者请求无法被服务器理解。
    - 401 Unauthorized：表示请求需要用户验证。
    - 403 Forbidden：表示请求被服务器拒绝。
    - 404 Not Found：表示请求的资源不存在。
5. 5xx（服务器错误状态码）：表示服务器在处理请求的过程中出现了错误。
    - 500 Internal Server Error：表示服务器在处理请求的过程中发生了错误。
    - 503 Service Unavailable：表示服务器暂时无法处理请求，一般是由于服务器过载或者维护。



#### 11.箭头函数跟普通函数的区别

箭头函数和普通函数的区别主要有以下几点：
1. 写法不同：箭头函数使用箭头 `=>` 来定义函数，而普通函数使用关键字 `function` 来定义函数。
2. this 指向不同：箭头函数没有自己的 `this`，它会继承上下文中的 `this`。而普通函数的 `this` 指向是动态的，它会根据函数的调用方式和上下文来确定。
3. arguments 对象不同：箭头函数没有自己的 `arguments` 对象，它会继承上下文中的 `arguments`。而普通函数有自己的 `arguments` 对象，它包含了所有传入函数的参数。
4. 不能作为构造函数：箭头函数不能用作构造函数，因为它没有自己的 `this`。
5. 不能使用 yield 关键字：箭头函数不能用作生成器函数，因为它不能使用 `yield` 关键字。
总的来说，箭头函数更加简洁、易读，并且更适合于函数式编程和简单的回调函数。而普通函数则更加灵活，可以根据需要进行动态的 `this` 绑定和参数处理。

#### 12.常用的操作数组的方法

数组是 JavaScript 中常用的数据结构之一，常见的数组操作方法包括：
1. push()：向数组的末尾添加一个或多个元素，并返回新数组的长度。会改变原数组。
2. pop()：从数组的末尾删除一个元素，并返回被删除的元素。会改变原数组。
3. shift()：从数组的开头删除一个元素，并返回被删除的元素。会改变原数组。
4. unshift()：向数组的开头添加一个或多个元素，并返回新数组的长度。会改变原数组。
5. slice()：返回一个从原数组中指定开始和结束位置（不包括结束位置）的新数组，不会改变原数组。
6. splice()：向/从数组中添加/删除元素，返回被删除的元素。会改变原数组。
7. concat()：连接两个或更多的数组，并返回新数组，不会改变原数组。
8. join()：将所有数组元素连接成一个字符串，不会改变原数组。
9. reverse()：反转数组中元素的顺序，会改变原数组。
10. sort()：对数组元素进行排序，会改变原数组。
需要注意的是，有些方法会改变原数组，而有些方法不会改变原数组，这取决于方法本身是否具有副作用。如果需要保留原数组，可以使用一些不会改变原数组的方法，例如 slice() 和 concat()。

split() 将字符串分割成数组

#### 13.计算属性跟watch的区别

Vue 中的计算属性和 watch 都可以用来监听数据的变化，但它们的作用和实现方式有所不同：
1. 计算属性是基于它所依赖的数据进行计算，并返回计算结果的属性。当所依赖的数据发生变化时，计算属性会重新计算，并更新页面上绑定的数据。计算属性适用于需要对数据进行复杂计算或者需要缓存计算结果的场景。
2. Watch 监听的是某个数据的变化，当该数据发生变化时，会触发执行指定的回调函数。Watch 适用于需要监听数据变化并进行异步操作的场景。
    总的来说，计算属性和 Watch 的区别在于：
3. 计算属性是一个属性，它返回一个计算结果，而 Watch 是一个监听器，它监听一个数据的变化。
4. 计算属性是基于依赖数据进行计算，Watch 监听的是指定数据的变化。
5. 计算属性适用于需要对数据进行复杂计算或者需要缓存计算结果的场景，而 Watch 适用于需要监听数据变化并进行异步操作的场景。
    需要注意的是，计算属性和 Watch 都可以监听数据的变化，但是它们的实现方式不同，选择哪种方式应该根据具体的业务场景来决定。

 

Vue.js 中的计算属性和 watch 都是用于响应式地处理数据的工具，但它们的使用场景和作用有所不同。

计算属性是一种依赖于其他属性值的属性，它会根据所依赖的属性值自动计算出新的值。计算属性通常用于处理复杂的逻辑和计算，以及需要缓存的数据。当计算属性依赖的属性发生变化时，计算属性会自动重新计算，并缓存计算结果，直到依赖的属性再次发生变化。这样可以避免重复计算，并提高性能。

watch 则是用于监听某个特定的数据变化，当该数据变化时执行特定的操作。watch 通常用于处理异步操作或需要执行副作用的逻辑。当被监听的数据发生变化时，watch 会自动执行回调函数，并传入新值和旧值作为参数。

因此，计算属性适用于处理复杂的逻辑和计算，并且需要缓存计算结果；而 watch 则适用于监听数据变化并执行特定操作，例如发送请求、更新 UI 等。

#### 14.配置全局主题色

在 Vue.js 项目中配置主题色可以通过使用 CSS 预处理器和 CSS 变量来实现。以下是一些基本步骤：

1. 安装 CSS 预处理器，例如 SASS 或 LESS。

2. 在项目中创建一个文件，例如 `variables.scss` 或 `variables.less`，用于存储主题颜色的变量。在该文件中定义您想要使用的颜色变量，例如：

   ```scss
   $primary-color: #007bff;
   $secondary-color: #6c757d;
   ```

3. 在应用程序中使用这些变量，例如：

   ```scss
   .header {
     background-color: $primary-color;
   }
   
   .footer {
     background-color: $secondary-color;
   }
   ```

4. 为了使这些变量在整个应用程序中可用，您可以在 `main.js` 中导入变量文件并将其应用于整个应用程序：

   ```js
   import Vue from 'vue';
   import App from './App.vue';
   import './variables.scss';
   
   Vue.config.productionTip = false;
   
   new Vue({
     render: h => h(App),
   }).$mount('#app');
   ```

这样，您就可以轻松地在 Vue.js 应用程序中配置主题颜色。

#### 15.css变量

CSS 变量（也称为 CSS 自定义属性）是一种用于存储和重用值的方法，这些值可以在整个样式表中使用。CSS 变量以 `--` 开头，并且可以在任何 CSS 属性中使用。

以下是一个使用 CSS 变量的示例：

```css
:root {
  --primary-color: #007bff;
}

.button {
  color: var(--primary-color);
  background-color: white;
  border: 1px solid var(--primary-color);
  padding: 10px;
}
```

在上面的示例中，我们在 `:root` 伪类中定义了一个名为 `--primary-color` 的 CSS 变量，并将其设置为蓝色。然后，在 `.button` 类中，我们使用 `var()` 函数将 `--primary-color` 变量应用于 `color` 和 `border` 属性。

使用 CSS 变量的好处之一是它们可以在运行时动态更改。例如，您可以使用 JavaScript 更改 `--primary-color` 变量的值，从而更改整个应用程序的主题颜色。

```js
document.documentElement.style.setProperty('--primary-color', '#ff0000');
```

这将将 `--primary-color` 变量的值更改为红色。

#### 16.swiper影响内部元素绝对定位

在使用 `swiper` 标签时，可能会出现内部元素的绝对定位受到影响的问题。这是因为 `swiper` 标签默认会添加 `overflow: hidden;` 样式，导致绝对定位的元素被裁剪。

为了解决这个问题，可以在 `swiper` 标签上添加 `position: relative;` 样式，以使内部元素的绝对定位相对于 `swiper` 标签而不是相对于页面。

以下是一个解决 `swiper` 标签影响内部元素绝对定位的示例：

```html
<swiper style="position: relative;">
  <swiper-item>
    <div style="position: absolute; top: 0; left: 0;">Absolute positioned element</div>
  </swiper-item>
</swiper>
```

在上面的示例中，我们将 `swiper` 标签的样式设置为 `position: relative;`，以便使内部元素的绝对定位相对于 `swiper` 标签而不是相对于页面。然后，在 `swiper-item` 中添加了一个绝对定位的 `div` 元素，以便演示绝对定位不再受到 `swiper` 标签的影响。

这样，您就可以在 `swiper` 标签内部使用绝对定位的元素，而不会受到 `swiper` 标签的影响

#### 17.微信小程序textarea穿透问题

在微信小程序中， textarea 元素默认会阻止触摸事件的传递，从而导致底部的元素无法响应触摸事件，这被称为“穿透问题”。



为了解决这个问题，可以使用 CSS 属性 `pointer-events` 将 `textarea` 元素设置为不接受任何触摸事件。然后，您可以在 `textarea` 元素的父元素上添加一个 `catchtouchmove` 事件监听器，以防止触摸事件穿透到底部元素。

以下是一个解决微信小程序 textarea 穿透问题的示例：

```html
<view class="container" catchtouchmove="preventTouchMove">
  <textarea></textarea>
</view>
```

```css
.container {
  position: relative;
}

textarea {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
```



```js
Page({
  preventTouchMove: function () {
    // 空函数，防止触摸事件穿透到底部元素
  }
})
```

在上面的示例中，我们将 `textarea` 元素的 `pointer-events` 属性设置为 `none`，并将其定位到父元素的顶部。然后，我们在父元素上添加了一个 `catchtouchmove` 事件监听器，以防止触摸事件穿透到底部元素。最后，我们在页面的 JavaScript 代码中定义了一个空函数，以便将其用作 `catchtouchmove` 事件的处理程序。

这样，您就可以解决微信小程序 textarea 穿透问题，并使底部元素响应触摸事件。

#### 18.less跟sass的异同

`less` 和 `sass` 都是 CSS 预处理器，它们可以让开发者使用类似编程语言的语法来编写 CSS 样式，从而提高开发效率和代码可维护性。下面是它们的相同点和不同点：

相同点：

- 都支持变量、嵌套、混合（Mixin）等功能，可以让样式代码更加简洁易读。
- 都支持导入（import）外部文件的样式。
- 都可以通过编译生成最终的 CSS 文件。

不同点：

- `less` 使用的是类似 JavaScript 的语法，而 `sass` 使用的是类似 Ruby 的语法。
- `less`变量是用@，`sass`变量使用$。
- `less` 的语法比 `sass` 更加宽松，例如可以省略大括号、分号等符号，而 `sass` 则需要严格遵守语法规则。
- `less` 的编译速度比 `sass` 快，但是 `sass` 的功能更加强大，例如支持条件语句、循环语句等高级功能。
- `less` 的学习曲线相对较低，适合初学者使用，而 `sass` 的学习曲线较陡峭，需要一定的编程基础和经验。

总的来说，`less` 和 `sass` 都是优秀的 CSS 预处理器，选择哪种取决于个人喜好和项目需求。

好的，我来更详细地介绍一下Less和Sass的异同点。

1. 语法

Less的语法类似于CSS，但是增加了一些扩展，如变量、嵌套规则、函数等。例如，以下是一个Less的样式规则：

```less
@primary-color: #007bff;

.button {
  background-color: @primary-color;
  color: #fff;
  &:hover {
    background-color: darken(@primary-color, 10%);
  }
}
```

Sass的语法则使用一种基于缩进的语法，看起来更像是一种编程语言。例如，以下是一个Sass的样式规则：

```scss
$primary-color: #007bff;

.button {
  background-color: $primary-color;
  color: #fff;
  &:hover {
    background-color: darken($primary-color, 10%);
  }
}
```

可以看到，Sass的语法更加简洁，但是需要注意缩进和花括号的使用。

2. 特性

Less和Sass都支持变量、嵌套规则、函数等特性，但是Sass还支持更多的高级特性，如条件语句、循环语句等。例如，以下是一个Sass的条件语句：

```scss
$primary-color: #007bff;

@if lightness($primary-color) > 50% {
  body {
    background-color: #000;
    color: #fff;
  }
} @else {
  body {
    background-color: #fff;
    color: #000;
  }
}
```

可以看到，在Sass中，可以使用@if语句根据条件来生成不同的样式规则。

3. 编译器

Less的编译器是用JavaScript实现的，可以在浏览器和服务器端运行。可以使用Less.js将Less样式编译成CSS，也可以使用Gulp、Webpack等构建工具进行自动化编译。

Sass的编译器是用Ruby编写的，需要安装Ruby环境才能使用。可以使用Sass命令行工具将Sass样式编译成CSS，也可以使用Gulp、Webpack等构建工具进行自动化编译。

当使用Less和Sass编写CSS时，混合是一种非常有用的技术，可以将一些常见的样式抽象出来，然后在需要的地方进行重用。下面是一个使用Less和Sass混合的例子：

###### less和scss的混合

使用Less混合：

```less
// 定义一个混合
.border-radius(@radius: 5px) {
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
  border-radius: @radius;
}

// 使用混合
.box {
  .border-radius(10px);
  background-color: #ccc;
  border: 1px solid #333;
}
```

使用Sass混合：

```scss
// 定义一个混合
@mixin border-radius($radius: 5px) {
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
  border-radius: $radius;
}

// 使用混合
.box {
  @include border-radius(10px);
  background-color: #ccc;
  border: 1px solid #333;
}
```

在上面的例子中，我们定义了一个名为`.border-radius`的Less混合和一个名为`border-radius`的Sass混合。这个混合接受一个参数，用于指定元素的圆角半径。然后我们在`.box`选择器中使用这个混合，将`.box`元素的圆角半径设置为10px。

总的来说，Less和Sass都是优秀的CSS预处理器，选择哪种取决于个人偏好和项目需求。如果你熟悉CSS语法，并且只需要一些基本的扩展功能，那么Less可能更适合你。如果你需要更高级的特性，如条件语句、循环语句等，那么Sass可能更适合你。

Less 和 Sass 都是 CSS 预处理器，它们提供了许多方便的语法和功能，可以帮助开发者更高效地编写 CSS 代码。下面是它们的一些语法区别：

1. 变量定义方式不同：Less 使用 `@` 符号定义变量，例如 `@my-color: #f00;`；Sass 使用 `$` 符号定义变量，例如 `$my-color: #f00;`。

2. 变量的作用域不同：Less 中的变量作用域是全局的，即在任何地方都可以使用；Sass 中的变量作用域可以通过嵌套规则来限制。

3. 嵌套规则不同：Less 中使用 `&` 来表示父元素，例如 `&:hover`；Sass 中使用 `&` 来连接父元素和子元素，例如 `&:hover > a`。

4. Mixin 的定义方式不同：Less 中使用 `.mixin-name` 来定义 Mixin，例如 `.border-radius(@radius: 5px) { border-radius: @radius; }`；Sass 中使用 `@mixin` 关键字来定义 Mixin，例如 `@mixin border-radius($radius: 5px) { border-radius: $radius; }`。

5. Mixin 的调用方式不同：Less 中使用 `.mixin-name()` 来调用 Mixin，例如 `.my-button { .border-radius(); }`；Sass 中使用 `@include` 关键字来调用 Mixin，例如 `.my-button { @include border-radius(); }`。

6. 继承语法不同：LESS 使用 :extend() 函数来实现继承，而 SASS 使用 @extend 关键字来实现继承。

   在 LESS 中，样式的继承使用 :extend() 函数来实现。使用 :extend() 函数时，需要指定要继承的样式名称，并通过 all 关键字来指定要继承的属性。例如：

   ```less
   .parent {
     color: red;
   }
   
   .child {
     &:extend(.parent all);
     font-size: 16px;
   }
   ```

   在上面的代码中，.child 样式继承了 .parent 样式，并继承了其中的所有属性。这意味着 .child 样式会继承 .parent 样式中的 color 属性，并且自己定义了 font-size 属性。

   在 SASS 中，样式的继承使用 @extend 关键字来实现。使用 @extend 关键字时，需要指定要继承的样式名称。例如：

   ```scss
   .parent {
     color: red;
   }
   
   .child {
     @extend .parent;
     font-size: 16px;
   }
   ```

   在上面的代码中，.child 样式继承了 .parent 样式，并继承了其中的所有属性。这意味着 .child 样式会继承 .parent 样式中的 color 属性，并且自己定义了 font-size 属性。

   需要注意的是，在使用样式继承时，要确保被继承的样式定义了所需要的属性，否则继承可能会失效。此外，过度使用样式继承可能会导致样式表的可读性变差，因此在使用样式继承时要慎重考虑。

###### sass的循环，if，函数

SASS 提供了循环、条件语句和函数等高级功能，可以帮助开发人员更方便地编写样式。

1. 循环：SASS 支持 for 循环和 while 循环。for 循环可以遍历一个数列或一个列表，并根据循环变量的值生成样式。例如：

```scss
@for $i from 1 through 3 {
  .item-#{$i} {
    width: 100px * $i;
  }
}
```

在上面的代码中，@for 循环从 1 到 3 遍历了一个数列，并生成了三个样式，分别是 .item-1、.item-2 和 .item-3，它们的宽度分别为 100px、200px 和 300px。

1. 条件语句：SASS 支持 if 和 else 条件语句。if 语句可以根据条件生成不同的样式。例如：

```scss
$color: red;

@if $color == red {
  .box {
    background-color: $color;
  }
} @else {
  .box {
    background-color: blue;
  }
}
```

在上面的代码中，如果 $color 变量的值是 red，则生成一个带有红色背景的 .box 样式，否则生成一个带有蓝色背景的 .box 样式。

1. 函数：SASS 支持自定义函数，可以将一些常用的样式逻辑封装起来，提高代码的可维护性。例如：

```scss
@function double($n) {
  @return $n * 2;
}

.box {
  width: double(50px);
}
```

在上面的代码中，定义了一个名为 double 的函数，它接受一个参数 $n，返回 $n 的两倍。然后在 .box 样式中使用了 double 函数，将 50px 作为参数传入，生成了一个宽度为 100px 的 .box 样式。

#### 19.url输入到页面渲染发生了啥

浏览器输入 URL 到页面渲染的过程大致可以分为以下几个步骤：

1. DNS 解析：浏览器首先会解析 URL 中的域名部分，将域名解析为 IP 地址，这一过程需要通过 DNS 服务器进行查询。如果 DNS 缓存中存在对应的 IP 地址，则直接返回结果，否则继续向上级 DNS 服务器进行查询，直到找到对应的 IP 地址为止。
2. 建立 TCP 连接：浏览器通过解析得到的 IP 地址和端口号，与服务器建立 TCP 连接。这一过程涉及到 TCP 的三次握手，即客户端向服务器发送 SYN 包，服务器回复 SYN+ACK 包，客户端再回复 ACK 包，建立连接成功。
3. 发送 HTTP 请求：建立 TCP 连接后，浏览器会向服务器发送 HTTP 请求，请求中包含请求方法、请求头、请求体等信息。请求方法通常为 GET 或 POST，请求头包含了客户端的一些信息，例如 User-Agent、Accept、Cookie 等。
4. 接收 HTTP 响应：服务器接收到请求后，会返回 HTTP 响应，响应中包含了状态码、响应头、响应体等信息。状态码表示服务器对请求的处理结果，例如 200 表示成功，404 表示资源不存在等。响应头包含了服务器的一些信息，例如 Server、Content-Type、Set-Cookie 等。响应体则是服务器返回的具体内容，例如 HTML、CSS、JavaScript 等。
5. 解析 HTML 并构建 DOM 树：浏览器接收到响应后，会根据响应头中的 Content-Type 判断响应体的类型，如果是 HTML，则开始解析 HTML 并构建 DOM 树。解析过程中，浏览器会将 HTML 标记解析为 DOM 节点，并根据节点间的关系构建出 DOM 树。同时，浏览器还会根据 HTML 中的 CSS 和 JavaScript 部分，解析出 CSSOM 和 JavaScript 对象模型。
6. 构建渲染树：在构建 DOM 树的同时，浏览器还会根据 CSSOM 构建渲染树。渲染树只包含需要显示的节点，例如可见的元素和文本节点，而不包含不可见的节点，例如 head 和 display:none 的元素。渲染树的构建过程中，浏览器会考虑节点的样式属性、尺寸和位置等信息。
7. 布局和绘制：在构建完渲染树后，浏览器会根据渲染树的信息，进行布局和绘制。布局过程中，浏览器会确定每个节点的位置和大小等信息，然后将它们放置在对应的位置上。绘制过程中，浏览器会将每个节点转换为屏幕上的像素，并进行绘制

#### 20.原型和原型链

在 JavaScript 中，每个对象（除了 null 和 undefined）都有一个原型对象（prototype），原型对象也可以看作是一个普通对象，它包含了一些共享的属性和方法。每个对象可以通过原型链（prototype chain）访问到它的原型对象，原型链是由一系列原型对象组成的链状结构，它的最顶端是 Object.prototype，也就是所有对象的原型。

具体来说，当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，那么 JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法为止。例如：

```js
let obj = { name: 'Alice' };
console.log(obj.toString()); // 输出 [object Object]
```

在这个例子中，我们访问了 obj 的 toString 方法，但是 obj 本身并没有这个方法，因此 JavaScript 引擎会沿着原型链向上查找，最终找到了 Object.prototype 上的 toString 方法。

可以通过 `Object.getPrototypeOf()` 方法获取一个对象的原型对象，例如：

```js
let obj = {};
console.log(Object.getPrototypeOf(obj) === Object.prototype); // 输出 true
```

可以通过 `__proto__` 属性来访问一个对象的原型对象，例如：

```js
let obj = {};
console.log(obj.__proto__ === Object.prototype); // 输出 true
```

需要注意的是，虽然 `__proto__` 属性在各个浏览器中都得到了广泛的支持，但它并不属于标准的 JavaScript API，因此在生产环境中应尽量避免使用。可以使用 `Object.getPrototypeOf()` 或者 ES6 中的 `Object.setPrototypeOf()` 方法来操作原型链。
#### 21.nextnick

在 Vue 中，当我们修改数据时，Vue 并不会立即更新 DOM，而是会将修改放入一个队列中，然后等到下一个事件循环时才会去更新 DOM。这是因为 Vue 使用了异步更新机制，以提高性能和减少不必要的 DOM 操作。

如果我们需要在某个数据修改后立即访问更新后的 DOM，就需要使用 `vm.$nextTick()` 方法。`vm.$nextTick()` 方法接收一个回调函数作为参数，该回调函数会在 DOM 更新完成后被调用。例如：

```js
new Vue({
  el: '#app',
  data: {
    message: 'Hello, Vue!'
  },
  methods: {
    updateMessage() {
      this.message = 'Hello, World!';
      this.$nextTick(() => {
        console.log(this.$el.textContent); // 输出 Hello, World!
      });
    }
  }
})
```

在这个例子中，当我们调用 `updateMessage()` 方法时，会将 `message` 的值修改为 'Hello, World!'，然后立即调用 `vm.$nextTick()` 方法并传入一个回调函数。在回调函数中，我们可以访问到更新后的 DOM，因为此时 DOM 已经被更新了。

需要注意的是，`vm.$nextTick()` 方法是异步执行的，因此回调函数的执行顺序是不确定的，如果多次调用 `vm.$nextTick()`，回调函数的执行顺序也是不确定的。此外，如果在回调函数中修改了数据，也需要再次调用 `vm.$nextTick()` 方法，以确保修改后的 DOM 已经被更新。

#### 22.强缓存和协商缓存

HTTP 协议中的缓存机制可以减少网络请求，提高网站性能。在浏览器中，缓存分为强缓存和协商缓存两种。

**强缓存**

强缓存是从浏览器缓存中直接读取数据，而不需要向服务器发送请求。浏览器会在第一次请求资源时，将资源的响应头中的 `Cache-Control` 或 `Expires` 字段缓存下来，之后再次请求该资源时，会根据缓存的字段判断是否需要向服务器发送请求。

在 `Cache-Control` 中，常见的字段有：

- `max-age`：指定缓存的最大有效时间，单位为秒。
- `no-cache`：指示客户端不应缓存资源，每次都需要向服务器发送请求验证资源是否过期。
- `no-store`：指示客户端不应缓存资源，并且不应将响应存储在任何本地缓存中。

在 `Expires` 中，指定的是一个绝对时间，表示资源的过期时间。

如果资源的缓存时间还没有过期，浏览器就会从缓存中读取数据，而不需要向服务器发送请求。这样可以减少网络请求，提高网站性能。

**协商缓存**

协商缓存是通过向服务器发送请求，与服务器进行协商，判断是否需要更新缓存。当浏览器发起请求时，会在请求头中添加 `If-Modified-Since` 或 `If-None-Match` 字段，分别表示上次请求时服务器返回的 `Last-Modified` 或 `ETag` 值。

服务器收到请求后，会根据这些字段判断资源是否发生了变化。如果资源没有变化，服务器会返回一个 304 Not Modified 响应，告诉浏览器可以使用缓存的资源。如果资源发生了变化，服务器会返回新的资源，并在响应头中添加新的 `Last-Modified` 或 `ETag` 值，供下次请求使用。

协商缓存相对于强缓存，可以在资源更新时及时更新缓存，避免使用过期的缓存资源。



协商缓存和强缓存是浏览器缓存机制中的两个重要概念。

强缓存是指浏览器在第一次请求资源时，将该资源的相关信息（如过期时间）存储在本地缓存中。当再次请求该资源时，浏览器会先检查本地缓存中的相关信息，如果该资源没有过期，则直接从本地缓存中读取，不再向服务器发送请求，这样可以大大提高页面加载速度。常见的强缓存方式有两种：Expires 和 Cache-Control。

协商缓存是指浏览器在第一次请求资源时，服务器会在响应头中返回资源的相关信息，如 ETag 和 Last-Modified 等。当再次请求该资源时，浏览器会将这些信息带上，发送给服务器，服务器会根据这些信息判断资源是否有更新，如果没有更新，则返回 304 Not Modified 状态码，告诉浏览器可以直接从本地缓存中读取资源，如果有更新，则返回最新的资源。常见的协商缓存方式有两种：Last-Modified 和 ETag。

需要注意的是，强缓存和协商缓存并不是互斥的，而是可以同时使用的。当强缓存失效时，浏览器会发送一个请求给服务器，然后根据服务器返回的响应头中的缓存标识（如 ETag 或 Last-Modified）来判断是否可以使用协商缓存，从而决定是否需要重新下载资源。

#### 23.请求在created跟mounted的区别

在 Vue 组件中，`created` 和 `mounted` 都是生命周期钩子函数，用于在不同的阶段执行一些操作。在数据请求方面，它们之间的主要区别在于组件是否已经挂载到 DOM 上。

`created` 钩子函数在组件实例被创建之后立即调用。在这个阶段，组件的实例已经被创建，但是它还没有被挂载到 DOM 上，因此在这个阶段进行数据请求是比较合适的。同时，由于组件还没有被挂载到 DOM 上，因此在这个阶段对 DOM 的操作是无效的。

`mounted` 钩子函数在组件挂载到 DOM 上之后立即调用。在这个阶段，组件已经被挂载到 DOM 上，因此可以进行一些需要访问 DOM 的操作。在这个阶段进行数据请求也是可以的，但是如果数据请求需要一定的时间，可能会导致用户看到一些空白内容，因此建议在 `mounted` 钩子函数中进行一些比较轻量级的操作，例如对 DOM 的操作或者一些简单的数据请求。

综上所述，如果数据请求不需要访问 DOM，那么建议在 `created` 钩子函数中进行；如果数据请求需要访问 DOM，那么可以在 `mounted` 钩子函数中进行。

#### 24.vue2的diff算法

Vue2使用的是基于snabbdom实现的虚拟DOM和patch算法。下面是Vue2的diff算法的步骤：

1. 首先将新旧节点进行比较，如果是相同节点，则进行patch操作，否则进行下一步。
2. 如果新旧节点不是相同节点，则先判断新节点是否有key属性，如果有，则使用key来查找旧节点中是否有相同key的节点。如果有，则判断这两个节点是否相同，如果相同，则进行patch操作，否则进行下一步。如果没有找到相同key的节点，则直接将新节点插入到旧节点的位置上。
3. 如果新节点没有key属性，则使用双指针算法进行比较。首先从新节点的头部和旧节点的头部开始比较，如果相同，则进行patch操作，并将指针向后移动。如果不同，则从新节点的尾部和旧节点的尾部开始比较，如果相同，则进行patch操作，并将指针向前移动。如果还是不同，则从新节点的头部和旧节点的尾部开始比较，如果相同，则进行patch操作，并将新节点插入到旧节点的头部，将旧节点的尾部删除。如果还是不同，则从新节点的尾部和旧节点的头部开始比较，如果相同，则进行patch操作，并将新节点插入到旧节点的尾部，将旧节点的头部删除。如果还是不同，则直接将新节点插入到旧节点的位置上。

这就是Vue2的diff算法的基本步骤。需要注意的是，Vue2的diff算法是基于虚拟DOM的，所以在实际使用中，需要先将数据转换成虚拟DOM，然后再进行比较和更新。另外，由于Vue2的diff算法是基于snabbdom实现的，所以可以参考snabbdom的文档了解更多细节。

#### 25.spa首屏优化

SPA（Single Page Application）应用在首屏加载速度慢的情况下，可以从以下几个方面进行优化：

1. 代码压缩和优化：对代码进行压缩和优化可以减少文件的大小，从而加快加载速度。可以使用Webpack等构建工具进行代码压缩和优化。
2. 按需加载：将页面中的组件和模块按需加载，可以减少首屏需要加载的资源量，从而提高加载速度。可以使用Vue的异步组件和Webpack的Code Splitting功能来实现按需加载。
3. 图片优化：对图片进行压缩和优化可以减小图片的大小，从而加快加载速度。可以使用图片压缩工具，如TinyPNG等。
4. 预加载：在首屏加载完成之前，可以预加载一些后续需要使用的资源，如图片、CSS、JS等，可以使用Webpack的Preload和Prefetch功能来实现。
5. 服务端渲染（SSR）：将一部分页面的渲染工作放到服务端进行，可以减少客户端的工作量，从而提高加载速度。可以使用Nuxt.js等框架来实现SSR。
6. CDN加速：使用CDN可以将静态资源缓存到CDN节点上，从而提高加载速度。可以使用七牛云、阿里云等CDN服务。
7. 缓存策略：对于一些不经常变化的资源，可以使用浏览器缓存策略，从而减少请求次数，提高加载速度。

以上是一些常用的SPA应用首屏加载速度慢的解决方案，可以根据具体情况进行选择和实现。

#### 26.ts继承

在 TypeScript 中，实现继承的方式有以下几种：

1. 类继承

类继承是 TypeScript 中最常用的继承方式。通过 `extends` 关键字可以实现一个类继承另一个类的属性和方法。子类可以通过 `super` 关键字调用父类的构造函数和方法。

下面是一个简单的示例：

```ts
class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  move(distance: number = 0) {
    console.log(`${this.name} moved ${distance}m.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log('Woof! Woof!');
  }
}

const dog = new Dog('Buddy');
dog.move(10); // 输出 "Buddy moved 10m."
dog.bark(); // 输出 "Woof! Woof!"
```

1. 接口继承

接口继承是 TypeScript 中实现继承的另一种方式。通过接口继承，一个接口可以继承另一个或多个接口的属性和方法。子接口可以通过 `extends` 关键字继承父接口的属性和方法。

下面是一个简单的示例：

```ts
interface Shape {
  color: string;
}

interface Square extends Shape {
  sideLength: number;
}

const square = {} as Square;
square.color = 'blue';
square.sideLength = 10;
console.log(square); // 输出 { color: 'blue', sideLength: 10 }
```

1. 混入

混入是 TypeScript 中一种比较高级的继承方式，它可以将多个类的功能组合到一个类中。通过 `class` 关键字和 `mixins` 函数可以实现混入。

下面是一个简单的示例：

```ts
class Disposable {
  isDisposed: boolean;

  dispose() {
    this.isDisposed = true;
  }
}

class Activatable {
  isActive: boolean;

  activate() {
    this.isActive = true;
  }

  deactivate() {
    this.isActive = false;
  }
}

class SmartObject implements Disposable, Activatable {
  constructor() {
    setInterval(() => console.log(this.isActive + ' : ' + this.isDisposed), 500);
  }

  interact() {
    this.activate();
  }

  // Disposable
  isDisposed: boolean = false;
  dispose: () => void;

  // Activatable
  isActive: boolean = false;
  activate: () => void;
  deactivate: () => void;
}

function mixin(base: any, ...mixins: any[]) {
  mixins.forEach((mixin) => {
    Object.getOwnPropertyNames(mixin.prototype).forEach((name) => {
      base.prototype[name] = mixin.prototype[name];
    });
  });

  return base;
}

const SmartObjectMixin = mixin(SmartObject, Disposable, Activatable);

const smartObj = new SmartObjectMixin();
setTimeout(() => smartObj.interact(), 1000);
```

#### 27.es6新增的对象方法

ES6（ECMAScript 2015）引入了许多新的对象方法，其中一些包括：

1. `Object.assign()`方法：将所有可枚举属性的值从一个或多个源对象复制到目标对象，并返回目标对象。
2. `Object.keys()`方法：返回一个由目标对象的所有可枚举属性的键组成的数组。
3. `Object.values()`方法：返回一个由目标对象的所有可枚举属性的值组成的数组。
4. `Object.entries()`方法：返回一个由目标对象的所有可枚举属性的键值对组成的数组。
5. `Object.getOwnPropertyDescriptors()`方法：返回一个由目标对象的所有属性描述符组成的对象。
6. `Object.fromEntries()`方法：将一个由键值对组成的数组转换为一个对象。
7. `Object.is()`方法：比较两个值是否相同，类似于 `===` 运算符，但有一些特殊的行为。
8. `Object.setPrototypeOf()`方法：设置一个对象的原型（即 `__proto__` 属性）。





1. `Object.assign(target, ...sources)`：将一个或多个源对象的属性复制到目标对象中，并返回目标对象。
2. `Object.keys(obj)`：返回一个包含对象自身可枚举属性名称的数组。
3. `Object.values(obj)`：返回一个包含对象自身可枚举属性值的数组。
4. `Object.entries(obj)`：返回一个包含对象自身可枚举属性键值对的数组。
5. `Object.fromEntries()`方法：将一个由键值对组成的数组转换为一个对象。
6. `Object.getOwnPropertyDescriptors(obj)`：返回一个对象，包含指定对象所有自身属性的描述符。
7. `Object.setPrototypeOf(obj, prototype)`：设置一个对象的原型到另一个对象或null。
8. `Object.is(value1, value2)`：比较两个值是否相同，与 === 运算符不同的是，Object.is(+0, -0) 和 Object.is(NaN, NaN) 返回 true。
9. `Object.freeze(obj)`：冻结一个对象，使其属性不可修改、添加或删除。
10. `Object.seal(obj)`：封闭一个对象，使其属性不可添加或删除，但属性值可以修改。
11. `Object.create(proto, [propertiesObject])`：使用指定的原型对象和属性创建一个新对象。

这些方法可以帮助开发者更方便地操作和处理对象。

#### 28.Set跟Map的区别

在JavaScript中，Set和Map都是ES6引入的新数据结构，它们都可以用于存储一组值。但是它们之间有一些不同之处：

1. Set是一组不重复的值的集合，而Map是一组键值对的集合。在Set中，每个值只能出现一次，而在Map中，每个键只能对应一个值。
2. Set的键和值是相同的，而Map的键和值是不同的。在Set中，添加和删除元素使用add()和delete()方法，而在Map中，添加和删除元素使用set()和delete()方法。
3. Set没有提供get()方法来获取某个值，而Map可以通过键获取对应的值。
4. Set没有提供forEach()方法，而Map可以通过forEach()方法遍历所有的键值对。

以下是一些示例代码，演示了Set和Map的基本用法：

```js
// 创建一个Set
const mySet = new Set([1, 2, 3]);

// 添加元素
mySet.add(4);

// 删除元素
mySet.delete(3);

// 判断元素是否存在
mySet.has(2); // true

// 遍历Set
mySet.forEach((value) => {
  console.log(value);
});

// 创建一个Map
const myMap = new Map();

// 添加键值对
myMap.set('key1', 'value1');
myMap.set('key2', 'value2');

// 删除键值对
myMap.delete('key1');

// 获取值
myMap.get('key2'); // 'value2'

// 遍历Map
myMap.forEach((value, key) => {
  console.log(key, value);
});
```

#### 29.Map和对象的区别

在JavaScript中，对象和Map都是用于存储键值对的数据结构，它们之间有一些不同之处：

1. 对象的键只能是字符串或Symbol类型，而Map的键可以是任意类型，包括基本类型和引用类型。
2. 对象具有原型，因此它们可能会包含从原型继承的属性。而Map是一种纯粹的键值对集合，不会包含任何继承的属性。
3. 对象的属性数量没有限制，而Map的大小可以通过size属性获取。
4. 对象可以使用点符号或方括号语法访问属性，而Map只能使用get()和set()方法访问键值对。
5. 对象可以使用字面量或构造函数创建，而Map只能使用构造函数创建。

以下是一些示例代码，演示了对象和Map的基本用法：

```js
// 创建一个对象
const myObj = {
  key1: 'value1',
  key2: 'value2'
};

// 添加属性
myObj.key3 = 'value3';

// 删除属性
delete myObj.key2;

// 获取属性
myObj.key1; // 'value1'

// 遍历对象
for (const key in myObj) {
  console.log(key, myObj[key]);
}

// 创建一个Map
const myMap = new Map();

// 添加键值对
myMap.set('key1', 'value1');
myMap.set('key2', 'value2');

// 删除键值对
myMap.delete('key1');

// 获取值
myMap.get('key2'); // 'value2'

// 遍历Map
myMap.forEach((value, key) => {
  console.log(key, value);
});
```

总的来说，对象和Map都是有用的数据结构，具体使用哪个取决于具体的需求。如果需要存储任意类型的键，或者需要一个纯粹的键值对集合，那么使用Map会更合适。如果需要一个具有原型的、灵活的键值对集合，那么使用对象会更合适。

#### 30.webpack如何实现打包阶段的优化

Webpack是一个强大的打包工具，可以将多个模块打包成一个或多个文件，但是在实际使用中，打包时间和打包后的文件大小都是需要考虑的问题。为了优化打包阶段，Webpack提供了一些功能和插件，可以帮助我们减少打包时间和打包后的文件大小。以下是一些常用的优化方法：

1. 使用Tree Shaking：Tree Shaking是Webpack中的一个功能，可以通过静态分析代码，删除未使用的代码。这样可以减少打包后的文件大小，提高加载速度。要使用Tree Shaking，需要确保代码中没有副作用，即代码执行时不会对外部环境产生影响。

2. 使用Code Splitting：Code Splitting是将代码拆分成多个小块，按需加载，可以减少首次加载的时间，提高用户体验。Webpack提供了多种Code Splitting的方式，包括使用动态import()语法、使用SplitChunksPlugin插件等。

3. 使用缓存：Webpack可以使用缓存来提高打包速度。如果代码没有发生变化，Webpack会使用缓存中的结果，而不是重新打包。可以使用cache-loader插件或者使用HardSourceWebpackPlugin插件来启用缓存。

4. 使用Parallelism：Webpack可以使用多进程并行处理任务，可以使用thread-loader插件或者HappyPack插件来启用并行处理。

5. 使用CDN：如果有一些第三方库或者公共资源，可以使用CDN来提高加载速度，减少服务器压力。

6. 压缩代码：可以使用UglifyJsPlugin插件来压缩代码，减小打包后的文件大小。

7. 减少文件搜索范围：可以通过resolve.alias配置项来减少Webpack搜索模块的范围，提高打包速度。

   

1. 使用Webpack的Tree Shaking功能来剔除未使用的代码，减小打包体积。
2. 使用Webpack的Code Splitting功能来将代码分割成多个小块，实现按需加载，减小首次加载时间。
3. 使用Webpack的缓存功能来缓存已经打包过的模块，避免重复打包，提高打包速度。
4. 使用Webpack的Scope Hoisting功能来减少模块之间的函数声明，减小打包体积。
5. 使用Webpack的Parallelism功能来并行处理多个模块的打包，提高打包速度。
6. 使用Webpack的DllPlugin和DllReferencePlugin来将第三方库单独打包成一个文件，避免重复打包，提高打包速度。
7. 使用Webpack的UglifyJSPlugin来压缩代码，减小打包体积。
8. 使用Webpack的HappyPack来将模块的解析和转换工作分配给多个进程，提高打包速度。
9. 使用Webpack的ModuleConcatenationPlugin来将模块的代码合并到一个函数中，减小打包体积。
10. 使用Webpack的AggressiveSplittingPlugin来分割代码，减小打包体积。

以上是一些常用的Webpack打包阶段的优化方法，不同的应用场景和需求可能需要不同的优化策略。

#### 31.Object.freeze 

Object.freeze()是JavaScript中一个用于冻结对象的方法。当一个对象被冻结后，它的属性将无法被修改、添加或删除。该方法返回被冻结的对象本身。

使用Object.freeze()可以使得对象的属性在被修改时抛出TypeError错误，从而保护对象的不可变性。被冻结的对象可以被读取，但是不能被修改。

以下是一个示例代码，演示了如何使用Object.freeze()方法：

```js
const myObj = {
  prop1: 'value1',
  prop2: 'value2'
};

Object.freeze(myObj);

myObj.prop1 = 'new value'; // 抛出TypeError错误
delete myObj.prop2; // 抛出TypeError错误

console.log(myObj.prop1); // 'value1'
console.log(myObj.prop2); // 'value2'
```

需要注意的是，Object.freeze()方法只能冻结对象本身的属性，而不能冻结对象中嵌套的对象的属性。如果需要冻结嵌套的对象，需要对每个嵌套的对象都调用Object.freeze()方法。

另外，被冻结的对象的属性仍然可以被修改，如果属性的值是一个对象，那么这个对象的属性仍然可以被修改。因此，Object.freeze()并不能完全保证对象的不可变性，需要根据具体的需求和情况选择合适的方法来保护对象的不可变性。

#### 32.MVVM和MVC区别

MVVM和MVC都是一种软件架构模式，用于组织代码和实现分离关注点的原则。它们有一些相似之处，但也有一些不同之处：

MVC（Model-View-Controller）是一种经典的软件架构模式，将应用程序分为三个部分：模型、视图和控制器。模型负责处理数据和业务逻辑，视图负责展示数据和用户界面，控制器负责协调模型和视图之间的交互。MVC模式将应用程序分离为三个部分，可以使得代码更加模块化、可维护性更高。但是MVC模式的缺点是，视图和控制器之间的关系比较紧密，视图的修改可能会影响控制器的逻辑。

MVVM（Model-View-ViewModel）是一种基于MVC模式的软件架构模式，将视图和模型之间的通信通过ViewModel来实现。ViewModel是一个中介层，负责处理视图和模型之间的交互，将模型数据绑定到视图上，当模型数据发生变化时，自动更新视图。MVVM模式将应用程序分离为三个部分：模型、视图和ViewModel。MVVM模式的优点是，视图和ViewModel之间的关系比较松散，视图的修改不会影响ViewModel的逻辑。

以下是MVVM和MVC的比较：

1. MVVM将视图和模型之间的通信通过ViewModel来实现，而MVC将视图和控制器之间的通信通过事件和回调函数来实现。
2. MVVM使用数据绑定来自动更新视图，而MVC需要手动更新视图。
3. MVVM将视图和ViewModel分离，而MVC将视图和控制器分离。
4. MVVM适合处理复杂的用户界面，而MVC适合处理简单的用户界面。

需要注意的是，MVVM和MVC都是一种软件架构模式，没有绝对的优劣之分，具体使用哪种模式取决于具体的需求和情况。

#### 33.Vue3比Vue2性能优化

Vue 3 相比 Vue 2 在性能上有很多改进，以下是一些主要的优化：

1. **响应式系统重写**：Vue 3 的响应式系统采用了 Proxy 对象，而不是 Object.defineProperty，这使得 Vue 3 的响应式系统更快、更灵活，同时还支持嵌套响应式对象和动态添加属性等功能。
2. **编译器优化**：Vue 3 的编译器采用了静态提升技术，可以将组件的模板编译成渲染函数，避免了运行时的模板编译，提高了渲染性能。
3. **更小的包体积**：Vue 3 的核心包体积比 Vue 2 更小，同时还可以通过按需引入来进一步减小包体积。
4. **更好的 Tree-shaking 支持**：Vue 3 的代码结构更加模块化，可以更好地支持 Tree-shaking，减小打包后的文件体积。
5. **更好的 TypeScript 支持**：Vue 3 的代码采用了 TypeScript 编写，提供了更好的类型检查和编辑器支持。

总的来说，Vue 3 在性能上有很多改进，可以让应用程序更快、更流畅地运行。

#### 34.判断一个属性是不是该对象自己的属性

hasOwnProperty

在JavaScript中，可以使用hasOwnProperty()方法来判断一个属性是否是该对象自己的属性。该方法接受一个字符串参数，表示要检查的属性名，如果该属性是对象自己的属性，则返回true，否则返回false。

例如，在以下示例中，使用hasOwnProperty()方法来判断属性是否是对象自己的属性：

```js
const obj = {
  prop1: 'value1',
  prop2: 'value2'
}

console.log(obj.hasOwnProperty('prop1')) // true
console.log(obj.hasOwnProperty('toString')) // false
```

在以上示例中，obj对象有两个属性prop1和prop2，其中prop1是对象自己的属性，prop2不是对象自己的属性。调用obj.hasOwnProperty('prop1')会返回true，调用obj.hasOwnProperty('toString')会返回false。

需要注意的是，如果一个属性是从原型链上继承而来的，则hasOwnProperty()方法会返回false。如果需要判断一个对象是否包含某个属性，不仅需要使用hasOwnProperty()方法，还需要考虑原型链上的属性。可以使用in运算符来判断一个属性是否存在于对象及其原型链中。例如：

```js
console.log('prop1' in obj) // true
console.log('toString' in obj) // true
```



在以上示例中，使用in运算符来判断属性是否存在于对象及其原型链中。调用'prop1' in obj会返回true，调用'toString' in obj也会返回true，因为toString()方法是从Object.prototype对象上继承而来的。
#### 35.阻止事件冒泡

JavaScript 中可以使用事件对象的 `stopPropagation()` 方法来阻止事件冒泡。当事件被触发时，事件会从目标元素逐级向上传播，直到传播到文档根节点。如果在事件处理程序中调用了 `stopPropagation()` 方法，则事件不会继续向上传播，从而阻止了事件冒泡。

示例代码（JavaScript）：

```js
document.getElementById('child').addEventListener('click', function(event) {
  console.log('child clicked');
  event.stopPropagation(); // 阻止事件冒泡
});

document.getElementById('parent').addEventListener('click', function(event) {
  console.log('parent clicked');
});

document.getElementById('grandparent').addEventListener('click', function(event) {
  console.log('grandparent clicked');
});
```

在上面的代码中，当单击 `child` 元素时，事件会首先触发 `child` 元素的 click 事件处理程序，然后再触发 `parent` 元素和 `grandparent` 元素的 click 事件处理程序。但是，由于在 `child` 元素的事件处理程序中调用了 `stopPropagation()` 方法，因此事件不会继续向上传播，从而阻止了事件冒泡。

需要注意的是，虽然 `stopPropagation()` 方法可以阻止事件冒泡，但是它并不能阻止事件捕获。如果需要同时阻止事件冒泡和事件捕获，可以使用事件对象的 `stopImmediatePropagation()` 方法。
#### 36.事件捕获的三个阶段

事件捕获是指从文档根节点开始，逐级向下传播事件的过程。在 JavaScript 中，事件捕获分为三个阶段：



1. **捕获阶段**：事件从文档根节点向下传播，直到达到事件的目标元素。在捕获阶段中，事件会首先被传递到文档根节点，然后逐级向下传播，直到传递到事件的目标元素。
2. **目标阶段**：事件到达目标元素后，进入目标阶段。在目标阶段中，事件会在目标元素上触发，执行目标元素的事件处理程序。
3. **冒泡阶段**：事件从目标元素开始向上传播，直到传递到文档根节点。在冒泡阶段中，事件会从目标元素开始向上传播，逐级向上传播，直到传递到文档根节点。

示例代码（JavaScript）：

```js
document.getElementById('child').addEventListener('click', function(event) {
  console.log('child clicked');
}, false); // false 表示在冒泡阶段处理事件

document.getElementById('parent').addEventListener('click', function(event) {
  console.log('parent clicked');
}, true); // true 表示在捕获阶段处理事件

document.getElementById('grandparent').addEventListener('click', function(event) {
  console.log('grandparent clicked');
}, true); // true 表示在捕获阶段处理事件
```

在上面的代码中，当单击 `child` 元素时，事件会首先在捕获阶段触发 `grandparent` 元素和 `parent` 元素的 click 事件处理程序，然后在目标阶段触发 `child` 元素的 click 事件处理程序，最后在冒泡阶段触发 `parent` 元素和 `grandparent` 元素的 click 事件处理程序。

需要注意的是，默认情况下，事件处理程序会在冒泡阶段触发。如果需要在捕获阶段触发事件处理程序，可以将 `addEventListener()` 方法的第三个参数设置为 `true`。

#### 37.websocket

WebSocket 是一种基于 TCP 协议的网络通信协议，可以在客户端和服务器之间建立双向通信的连接。与传统的 HTTP 协议不同，WebSocket 协议可以实现服务器主动向客户端推送数据，而不需要客户端主动向服务器发起请求。

WebSocket 协议的工作流程如下：

1. 客户端向服务器发起 WebSocket 握手请求，请求中包含 Upgrade 头和 Connection 头，表示要升级协议为 WebSocket。
2. 如果服务器支持 WebSocket 协议，会返回一个包含 Upgrade 头和 Connection 头的响应，表示协议已经升级为 WebSocket。
3. 客户端和服务器之间建立 WebSocket 连接，可以进行双向通信。
4. 客户端和服务器之间可以发送和接收消息，消息可以是文本、二进制数据等格式。
5. 当需要关闭 WebSocket 连接时，客户端或服务器可以发送一个关闭帧，表示要关闭连接。

WebSocket 协议的优点是能够实现实时通信、双向通信和低延迟，适用于在线游戏、即时通讯、实时数据推送等场景。同时，WebSocket 协议也具有较好的跨平台和跨域支持，可以在不同的浏览器和操作系统之间进行通信。

示例代码（JavaScript）：

```js
javascriptCopy code// 创建 WebSocket 连接
const socket = new WebSocket('wss://example.com');

// 监听连接成功事件
socket.addEventListener('open', function(event) {
  console.log('WebSocket connected');
});

// 监听接收消息事件
socket.addEventListener('message', function(event) {
  console.log('Received message:', event.data);
});

// 发送消息
socket.send('Hello, server!');

// 关闭连接
socket.close();
```

在上面的代码中，首先创建了一个 WebSocket 连接，然后监听连接成功事件和接收消息事件。当连接成功后，可以通过 `send()` 方法向服务器发送消息，当接收到服务器发送的消息时，会触发 `message` 事件。最后，可以通过 `close()` 方法关闭 WebSocket 连接。

#### 38.HTTP各个版本的区别

HTTP（超文本传输协议）是一种用于在网络上传输数据的协议。HTTP 有多个版本，包括 HTTP/0.9、HTTP/1.0、HTTP/1.1、HTTP/2 和 HTTP/3。下面是这些版本之间的一些主要区别：

- HTTP/0.9：这是最初的版本，只支持 GET 请求方法，并且响应只能是 HTML 格式。这个版本没有头部信息，也没有状态码。
- HTTP/1.0：这个版本引入了头部信息和状态码。它支持多种请求方法，包括 GET、POST 和 HEAD。但是，它每次只能发送一个请求，每个请求都需要新建一个 TCP 连接。
- HTTP/1.1：这个版本引入了持久连接（keep-alive），允许在单个连接上发送多个请求。它还支持管道化（pipelining），允许在一个连接上同时发送多个请求。HTTP/1.1 还引入了一些新的请求方法，例如 OPTIONS、PUT 和 DELETE。
- HTTP/2：这个版本引入了二进制协议，将请求和响应拆分成二进制帧进行传输，而不是文本。这种方式可以更好地压缩数据、减少延迟和提高性能。HTTP/2 还支持服务器推送（server push），允许服务器在客户端请求之前主动发送资源。
- HTTP/3：这个版本基于 QUIC 协议，而不是 TCP。QUIC 具有更好的错误恢复机制、更好的拥塞控制和更快的连接建立速度。HTTP/3 还支持多路复用（multiplexing），允许在一个连接上同时发送多个请求和响应。

总的来说，随着 HTTP 版本的不断升级，HTTP 协议变得更加高效、安全和灵活。
#### 39.Vue的插槽

在 Vue 中，插槽（slot）是一种用于在组件中插入内容的机制。Vue 中的插槽分为以下两种类型：
- 命名插槽（Named Slots）：命名插槽允许在组件中定义多个插槽，并为每个插槽指定一个名称。这样就可以在父组件中使用具有相同名称的 `<template>` 元素来填充对应的插槽。例如：
- 

```vue
<!-- 子组件 -->
<template>
  <div>
    <h2><slot name="title"></slot></h2>
    <p><slot name="content"></slot></p>
  </div>
</template>

<!-- 父组件 -->
<template>
  <div>
    <child-component>
      <template v-slot:title>这是标题</template>
      <template v-slot:content>这是内容</template>
    </child-component>
  </div>
</template>
```

- 作用域插槽（Scoped Slots）：作用域插槽允许在插槽中访问子组件的数据和方法，从而实现更灵活的内容渲染。在子组件中，使用 `<slot> `元素的属性来声明作用域插槽，并将需要传递给父组件的数据作为插槽的参数。在父组件中，使用 `<template>`元素来填充作用域插槽，并将子组件传递的数据作为模板的参数。例如：

```vue
<!-- 子组件 -->
<template>
  <div>
    <slot :item="item" v-for="item in items"></slot>
  </div>
</template>

<!-- 父组件 -->
<template>
  <div>
    <child-component>
      <template v-slot:default="slotProps">
        <div>{{ slotProps.item }}</div>
      </template>
    </child-component>
  </div>
</template>
```

以上是 Vue 中两种常见的插槽类型。插槽是 Vue 中非常强大的功能，可以帮助我们更好地组织和复用组件。

#### 40.vue响应式数据的原理

在 Vue 2 中，数据响应式是通过 Object.defineProperty 方法来实现的。当 Vue 创建一个组件实例时，它会对组件的数据进行递归地遍历，将每个属性都转换为 getter 和 setter，并且在内部建立一个依赖追踪的系统。当组件渲染时，每个属性的 getter 都会被调用一次，这样 Vue 就能够追踪到该属性被哪些组件所依赖。当该属性的 setter 被调用时，Vue 就会通知相关的组件进行重新渲染。

在 Vue 3 中，数据响应式是通过 ES6 的 Proxy 对象来实现的。Proxy 对象可以拦截 JavaScript 对象的访问，从而实现对对象的监听和修改。当 Vue 创建一个组件实例时，它会创建一个代理对象，用于拦截组件的数据访问和修改。当组件渲染时，Vue 会跟踪每个属性的访问，并将其保存在一个依赖追踪的系统中。当属性被修改时，Vue 就会通知相关的组件进行重新渲染。

相比于 Vue 2，Vue 3 的数据响应式原理使用了 ES6 的 Proxy 对象，这种方式具有更好的性能和更强的功能。Proxy 对象可以监听整个对象的变化，而 Object.defineProperty 只能监听对象的属性。此外，使用 Proxy 对象还可以避免一些常见的问题，例如数组下标的变化和对象属性的添加和删除等。

总的来说，Vue 2 和 Vue 3 的数据响应式原理都是通过监听数据的访问和修改来实现的，但是 Vue 3 使用了 ES6 的 Proxy 对象，具有更好的性能和更强的功能。

#### 41.vue3为什么使用Proxy

Vue 3 之所以改用 Proxy 对象实现数据响应式，是因为 Proxy 对象相比 Object.defineProperty 具有以下优点：

1. 更好的性能：Vue 2 使用 Object.defineProperty 来监听数据变化，这种方式对于数组和对象的监听比较麻烦，需要对数组的 push、pop、shift、unshift、splice 等方法进行特殊处理。而使用 Proxy 对象可以直接监听整个对象的变化，不需要对数组进行特殊处理，因此具有更好的性能。
2. 更强的功能：Proxy 对象可以监听整个对象的变化，而 Object.defineProperty 只能监听对象的属性。使用 Proxy 对象可以避免一些常见的问题，例如数组下标的变化和对象属性的添加和删除等。此外，Proxy 对象还可以拦截更多的操作，例如 has、construct、setPrototypeOf 等操作。
3. 更好的可维护性：使用 Proxy 对象可以使代码更加简洁和易于维护。Vue 3 的响应式系统使用了一些新的 API，例如 reactive、ref、computed 等，这些 API 可以帮助开发者更好地组织和管理组件的数据。

总的来说，Vue 3 之所以改用 Proxy 对象实现数据响应式，是因为 Proxy 对象具有更好的性能、更强的功能和更好的可维护性。使用 Proxy 对象可以使 Vue 的响应式系统更加强大和灵活，帮助开发者更好地构建高性能的应用程序。



Vue 3中使用 `Proxy` 代替 `defineProperty` 的原因主要有以下几点：



1. **更好的性能**：`Proxy` 比 `defineProperty` 更快，因为 `Proxy` 可以直接监听整个对象而不是像 `defineProperty` 一样只能遍历对象的每个属性进行监听。
2. **更好的类型检查**：使用 `Proxy` 可以更方便地进行类型检查，因为它可以直接监听整个对象，而不像 `defineProperty` 那样需要为每个属性设置类型。
3. **更好的错误提示**：使用 `Proxy` 可以更容易地发现错误，因为它会在访问不存在的属性时直接抛出错误，而 `defineProperty` 会返回 `undefined`，这可能会导致一些难以追踪的错误。
4. **更好的可扩展性**：使用 `Proxy` 可以更方便地实现一些高级功能，比如动态添加和删除属性、属性重命名等。



总的来说，使用 `Proxy` 可以让代码更加简洁、易读、易维护，并且能够提高性能和可扩展性。
#### 42.项目中遇到的问题

在项目中遇到的难点有很多，下面我举几个例子：

1. 性能优化：在一个较为复杂的项目中，页面渲染和数据请求的速度可能会比较慢，导致用户体验不佳。为了解决这个问题，我采取了一些优化措施，例如使用懒加载、减少 HTTP 请求、使用 CDN 加速等方式来提高页面加载速度和性能。
2. 跨域问题：在一个项目中，我需要从不同的域名下获取数据，但是由于浏览器的同源策略，无法直接访问其他域名下的数据。为了解决这个问题，我使用了 JSONP、CORS、代理等方式来实现跨域访问数据。
3. 组件复用：在一个项目中，我需要多次使用相同的组件，但是每次使用时都需要重新编写代码，导致代码冗余。为了解决这个问题，我将相同的组件抽象出来，封装成一个单独的组件库，并在需要使用时直接引用组件库中的组件，从而实现组件的复用和代码的重用。
4. 移动端适配：在一个项目中，我需要将网站适配到移动端，但是由于移动设备的屏幕尺寸和分辨率不同，导致页面在不同设备上显示效果不同。为了解决这个问题，我采用了响应式布局、rem 或 vw/vh 单位等方式来实现移动端适配。

总的来说，项目中遇到的难点各有不同，但是在解决问题的过程中，需要我们具备一定的技术能力和解决问题的思维方式。在面试时，我们可以结合具体的项目经历，详细地介绍遇到的问题、解决方案和实现效果，以展现自己的技术能力和解决问题的能力。

#### 43.数组转字符串

可以使用 `join()` 方法将 JavaScript 数组转换为字符串。`join()` 方法将数组中的所有元素连接在一起，返回一个字符串。

例如，将一个数组转换为逗号分隔的字符串：

```js
const arr = ["apple", "banana", "orange"];
const str = arr.join(", ");
console.log(str); // "apple, banana, orange"
```

在 `join()` 方法中，你可以传递一个字符串参数，它将作为元素之间的分隔符。如果不传递参数，则默认使用逗号作为分隔符。

字符串转数组

可以使用 JavaScript 的 `split()` 方法将字符串分割成数组。`split()` 方法接受一个分隔符作为参数，并返回一个包含分割后的字符串的数组。

例如，将一个逗号分隔的字符串转换为数组：

```js
const str = "apple, banana, orange";
const arr = str.split(", ");
console.log(arr); // ["apple", "banana", "orange"]
```

在 `split()` 方法中，你可以传递一个字符串参数，它将作为分隔符。如果不传递参数，则默认使用空格作为分隔符。

#### 44.字符串转数组

可以使用 JavaScript 的 `split()` 方法将字符串分割成数组。`split()` 方法接受一个分隔符作为参数，并返回一个包含分割后的字符串的数组。

例如，将一个逗号分隔的字符串转换为数组：

```js
const str = "apple, banana, orange";
const arr = str.split(", ");
console.log(arr); // ["apple", "banana", "orange"]
```

在 `split()` 方法中，你可以传递一个字符串参数，它将作为分隔符。如果不传递参数，则默认使用空格作为分隔符。

#### 45.函数柯里化

函数柯里化（Currying）是一种将接受多个参数的函数转换成一系列接受一个参数的函数的技术。这些函数被称为柯里化函数。柯里化函数返回新的函数，新函数接受一个参数，并返回一个新的函数，直到所有参数都被处理完毕，最后返回最终结果。

例如，考虑一个接受三个参数的函数 `add(a, b, c)`，通过柯里化可以将其转换为一系列接受一个参数的函数：

```js
function add(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    }
  }
} 

const result = add(1)(2)(3);
console.log(result); // 6
```

在这个例子中，`add()` 函数被转换为一系列接受一个参数的函数。每个函数都返回另一个接受一个参数的函数，直到所有参数都被处理完毕，最后返回最终结果。

函数柯里化可以使函数更加灵活和可复用。它使得我们可以将一个函数转换为一个接受部分参数的函数，并在稍后调用它，或者将其作为参数传递给其他函数。
#### 46.Intersection 封装图片懒加载组件

1. 安装Intersection Observer的polyfill，以便在不支持Intersection Observer的浏览器上使用它。可以使用npm安装polyfill：

   ```
   npm install intersection-observer
   ```

2. 在Vue组件中引入Intersection Observer：

   ```
   import 'intersection-observer'
   ```

以下是使用Intersection Observer封装图片懒加载组件的示例。该组件可以通过传递一个图片数组来实现图片懒加载。

```vue
<template>
  <div>
    <img
      v-for="(item, index) in images"
      :key="index"
      v-lazy="item.src"
      :data-src="item.src"
    />
  </div>
</template>

<script>
export default {
  name: 'LazyLoad',
  data() {
    return {
      images: []
    }
  },
  props: {
    imageList: {
      type: Array,
      required: true
    }
  },
  mounted() {
    this.images = this.imageList
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const lazyImage = entry.target
          lazyImage.src = lazyImage.dataset.src
          observer.unobserve(lazyImage)
        }
      })
    })
    const lazyImages = document.querySelectorAll('img[data-src]')
    lazyImages.forEach(lazyImage => {
      observer.observe(lazyImage)
    })
  }
}
</script>

<style>
/* 可以添加一些样式来占位，以防止图片加载前页面布局错乱 */
img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
</style>
```

在父组件中，可以通过传递一个图片数组来使用该组件：

```vue
<template>
  <div>
    <lazy-load :image-list="imageList"></lazy-load>
  </div>
</template>

<script>
import LazyLoad from '@/components/LazyLoad.vue'

export default {
  name: 'App',
  components: {
    LazyLoad
  },
  data() {
    return {
      imageList: [
        { src: 'https://example.com/image1.jpg' },
        { src: 'https://example.com/image2.jpg' },
        { src: 'https://example.com/image3.jpg' }
      ]
    }
  }
}
</script>
```

这样，当LazyLoad组件被挂载时，它会使用Intersection Observer监听所有的图片元素，当图片元素进入视窗时，Intersection Observer会触发回调函数，将图片的data-src属性值赋给src属性，从而实现图片懒加载。

#### 47.new操作符做了什么

new做了什么？
new操作符就是创建一个给定构造函数的实例对象；
具体流程就是
1创建一个新的对象obj
2将这个对象与构造函数通过原型链连接起来
3将构造函数的this与这个对象绑定
4通过判断返回的类型，如果是基础类型就不管，返回对象就是那个对象



在 JavaScript 中，`new` 操作符用于创建一个对象实例。它的具体行为如下：

1. 创建一个新对象。
2. 将新对象的原型设置为构造函数的 `prototype` 属性。
3. 将构造函数的 `this` 绑定到新对象上。
4. 执行构造函数，并将其参数传入。
5. 如果构造函数返回一个对象，则返回该对象；否则返回新创建的对象。

举个例子，假设有一个构造函数 `Person`：

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}
```

使用 `new` 操作符创建一个 `Person` 对象实例的语法如下：

```js
const person = new Person('John', 30);
```



这将创建一个新对象，其 `name` 属性为 `'John'`，`age` 属性为 `30`。该对象的原型将被设置为 `Person.prototype`。最后，构造函数 `Person` 的 `this` 绑定到新对象上，并执行其中的代码。由于 `Person` 函数没有显式返回任何值，因此将返回新创建的对象 `person`



#### 48.apply，call，bind 区别

三者都是改变this的指向 都有两个参数
apply 第一个参数就是this指向 改变this指向后会立即执行 只会改变一次
第二个 参数是一个数组 是 传入的参数
call 第一个参数是this指向，改变this指向后会立即执行 只会改变一次
第二个参数是参数列表 
bind 改变后不会立即执行 而是返回一个永久改变this的函数 第二个参数可分多次传入

#### 49.回流和重绘

1回流指的是当元素的属性发生改变但是影响布局的时候 比如改变宽度高度 内外边距等 就会产生回流（相当于刷新页面的一个操作）
2重绘值得是元素的属性发生改变 但是不会影响布局 比如背景颜色 透明度 字体样式


#### 50.精度丢失

这是因为在JavaScript中，数字都是以浮点数形式表示的，而浮点数在计算机中是以二进制表示的。有些十进制小数无法精确地转换为有限的二进制小数，例如0.1和0.2。这些小数在转换为二进制时会变成无限循环小数，但是计算机只能存储有限的位数，因此会出现精度误差。

在JavaScript中，0.2和0.1都无法精确地表示为二进制小数，它们的实际值可能略微偏离它们的十进制表示。因此，当它们相加时，可能会出现微小的舍入误差，导致它们的和不等于0.3。

为了避免这种问题，可以使用JavaScript中的一些技巧来处理浮点数运算，例如将小数转换为整数进行计算，或使用特殊的库来处理精确计算。

为什么会有这个问题呢

这个问题是由于计算机在处理浮点数时的精度问题导致的。计算机在内部使用二进制来表示数字，而浮点数在二进制中的表示方式有时会导致精度损失。

在十进制中，0.1和0.2都是无限循环小数，例如：

0.1 = 0.0001100110011001100110011001100110011001100110011... 0.2 = 0.0011001100110011001100110011001100110011001100110...

当这些数被转换为二进制时，它们变成了无限循环小数。由于计算机内存的限制，只能存储有限的位数，因此在计算机内部表示这些数时，它们的精度会有所损失。

例如，在JavaScript中，0.1在内部表示为：

0.1000000000000000055511151231257827021181583404541015625

这个值略微偏离0.1的真实值，因此当0.1和0.2相加时，可能会出现微小的舍入误差，导致它们的和不等于0.3。

要解决这个问题，可以使用特殊的技巧或库来处理浮点数，例如将小数转换为整数进行计算，或使用BigNumber.js等库来进行精确计算。



#### 51.Promise

Promise 是一种用于处理异步操作的 JavaScript 对象。它可以使异步代码更加易于阅读和理解，并且可以更好地处理回调地狱问题。

在 Promise 中，一个异步操作可以被表示为一个对象，该对象有三个状态：pending（进行中）、fulfilled（已完成）和rejected（已拒绝）。当一个异步操作完成时，它会从 pending 状态转换为 fulfilled 状态，如果出现错误则会转换为 rejected 状态。

Promise 对象有两个主要方法：then() 和 catch()。then() 方法用于处理已完成的异步操作，catch() 方法用于处理已拒绝的异步操作。这两个方法都接受一个回调函数作为参数，该回调函数将在异步操作完成或被拒绝时被调用。

以下是一个使用 Promise 的简单示例：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const randomNumber = Math.random();
    if (randomNumber < 0.5) {
      resolve(randomNumber);
    } else {
      reject(new Error('Random number is too large'));
    }
  }, 1000);
});

promise.then(result => {
  console.log(`The random number is ${result}`);
}).catch(error => {
  console.error(error);
});

```

在上面的示例中，我们创建了一个 Promise 对象，它将在 1 秒后生成一个随机数字。如果生成的数字小于 0.5，Promise 将被解决并输出结果，否则它将被拒绝并输出错误。

当 Promise 被解决时，then() 方法将被调用并输出结果。当 Promise 被拒绝时，catch() 方法将被调用并输出错误。

除了 `then()` 和 `catch()` 方法，Promise 还有一些其他方法：

1. `finally(onFinally)` 方法：在 Promise 被解决或拒绝后，无论如何都会被调用。该方法接受一个回调函数作为参数，该回调函数将在 Promise 被解决或拒绝后被调用。`finally()` 方法返回一个新的 Promise 对象，该对象的状态和值与原始 Promise 对象相同。
2. `Promise.all(iterable)` 方法：接受一个可迭代对象（如数组）作为参数，返回一个新的 Promise 对象。该对象在所有 Promise 对象都被解决后被解决，并将解决值作为数组传递给回调函数。如果任何一个 Promise 被拒绝，则该对象将被拒绝并传递拒绝原因。
3. `Promise.race(iterable)` 方法：接受一个可迭代对象作为参数，返回一个新的 Promise 对象。该对象在任何一个 Promise 对象被解决或拒绝后立即被解决或拒绝，并将该 Promise 的值或原因传递给回调函数。
4. `Promise.allSettled(iterable)` 方法：接受一个可迭代对象作为参数，返回一个新的 Promise 对象。该对象在所有 Promise 对象都被解决或拒绝后被解决，并将一个包含所有 Promise 对象的状态和值的数组传递给回调函数。
5. `Promise.any(iterable)` 方法：接受一个可迭代对象作为参数，返回一个新的 Promise 对象。该对象在任何一个 Promise 对象被解决后立即被解决，并将该 Promise 的值传递给回调函数。如果所有 Promise 都被拒绝，则该对象将被拒绝并传递所有拒绝原因的数组。

这些方法都是在 ES6 中引入的，可以让 Promise 更加强大和灵活

#### 51.1.Promsie，和async/await的区别

在 JavaScript 中，`Promise` 和 `async/await` 都是用于处理异步操作的解决方案。

`Promise` 是一种对象，它代表了一个尚未完成的异步操作，并且提供了一组方法来处理异步操作的成功或失败。当一个异步操作完成时，`Promise` 对象会被 resolve（成功）或 reject（失败），并且可以通过 `.then()` 和 `.catch()` 方法来处理成功或失败的结果。

`async/await` 则是一种基于 `Promise` 的语法糖，它可以让异步操作的代码看起来更像同步代码。使用 `async` 关键字来定义一个异步函数，异步函数中可以使用 `await` 关键字来等待一个异步操作的完成，并且将异步操作的结果作为返回值返回。

二者的区别在于，`Promise` 是一种更底层的解决方案，它提供了一组基础的方法来处理异步操作，而 `async/await` 则是基于 `Promise` 的一种更高层次的解决方案，它可以让异步操作的代码更加简洁、易读。同时，`async/await` 还可以通过 `try/catch` 来处理异步操作的错误，使得代码的错误处理更加方便。

总的来说，`Promise` 和 `async/await` 都是处理异步操作的解决方案，二者的使用场景和优缺点不同，具体使用哪种方式取决于具体的需求和场景。

#### 52.typescrip实现继承的方法

在 TypeScript 中，实现继承的方式与 JavaScript 类似。以下是 TypeScript 中实现继承的几种方式：

1. 类继承：使用 `extends` 关键字来实现类之间的继承。子类可以继承父类的属性和方法，并且可以重写父类的方法或添加新的方法。例如：

```ts
class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  makeSound() {
    console.log('The animal makes a sound');
  }
}

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }

  makeSound() {
    console.log('The dog barks');
  }

  fetch() {
    console.log('The dog fetches a ball');
  }
}

const myDog = new Dog('Fido');
console.log(myDog.name); // Output: Fido
myDog.makeSound(); // Output: The dog barks
myDog.fetch(); // Output: The dog fetches a ball
```

1. 接口继承：使用 `extends` 关键字来实现接口之间的继承。子接口可以继承父接口的属性和方法，并且可以添加新的属性和方法。例如：

```ts
interface Animal {
  name: string;
  makeSound(): void;
}

interface Pet extends Animal {
  owner: string;
  play(): void;
}

class Dog implements Pet {
  name: string;
  owner: string;

  constructor(name: string, owner: string) {
    this.name = name;
    this.owner = owner;
  }

  makeSound() {
    console.log('The dog barks');
  }

  play() {
    console.log('The dog plays fetch');
  }
}

const myDog: Pet = new Dog('Fido', 'John');
console.log(myDog.name); // Output: Fido
console.log(myDog.owner); // Output: John
myDog.makeSound(); // Output: The dog barks
myDog.play(); // Output: The dog plays fetch
```

1. 混合继承：使用类继承和接口继承的组合来实现混合继承。可以使用类继承来继承类的属性和方法，使用接口继承来继承接口的属性和方法。例如：

```ts
interface Animal {
  name: string;
  makeSound(): void;
}

class Mammal {
  hasHair = true;
}

class Dog extends Mammal implements Animal {
  name: string;

  constructor(name: string) {
    super();
    this.name = name;
  }

  makeSound() {
    console.log('The dog barks');
  }

  fetch() {
    console.log('The dog fetches a ball');
  }
}

const myDog: Dog = new Dog('Fido');
console.log(myDog.name); // Output: Fido
console.log(myDog.hasHair); // Output: true
myDog.makeSound(); // Output: The dog barks
myDog.fetch(); // Output: The dog fetches a ball
```

这些是 TypeScript 中实现继承的几种方式，开发者可以根据实际需求选择合适的方式。


#### 53.link 和@import的区别

link 是一个html标签
@import 是css提供的一种方式 所以是写在style标签里面的
link是加载html的时候 同时加载css
@import是先加载完html 再加载css
性能上 link 比@要好
兼容性差别 @是css2 提出 老浏览器不支持
link兼容性好一些
link的样式 是受js控制的 @不可以收js控制

#### 54.图片的间隙bug怎么解决

给图片元素 display：block；
或者给父元素加上 font-size：0
或者浮动
图片是行内元素



#### 55.async和defer

在 HTML 中，`<script>` 标签用于加载 JavaScript 文件。`<script>` 标签有两个属性：`async` 和 `defer`，可以用来控制 JavaScript 文件的加载和执行。以下是它们的作用：

1. async 属性：表示异步加载 JavaScript 文件。当浏览器遇到带有 `async` 属性的 `<script>` 标签时，它会在下载 JavaScript 文件的同时继续解析 HTML 文档。当 JavaScript 文件下载完成后，浏览器会立即执行它。如果有多个带有 `async` 属性的 `<script>` 标签，它们的执行顺序是不确定的，因为它们可能会在任何时候下载和执行。
2. defer 属性：表示延迟加载 JavaScript 文件。当浏览器遇到带有 `defer` 属性的 `<script>` 标签时，它会在下载 JavaScript 文件的同时继续解析 HTML 文档。但是，JavaScript 文件不会立即执行，而是在 HTML 文档解析完成后、`DOMContentLoaded` 事件触发之前执行。如果有多个带有 `defer` 属性的 `<script>` 标签，它们的执行顺序是按照它们在 HTML 文档中出现的顺序依次执行的。

使用 `async` 和 `defer` 属性可以提高 JavaScript 文件的加载性能，避免阻塞 HTML 文档的解析和渲染。如果 JavaScript 文件不需要立即执行，可以使用 `defer` 属性；如果 JavaScript 文件需要立即执行，但不需要等待 HTML 文档解析完成，可以使用 `async` 属性。



#### 56.清除浮动

在 HTML 和 CSS 中，浮动（float）是一种常用的布局技术。但是，当一个元素浮动时，它可能会影响到后面的元素的布局，导致出现各种问题，例如高度坍塌等。为了解决这些问题，我们需要清除浮动。

以下是几种清除浮动的方法：

1. 使用空元素清除浮动

这是一种比较早期的清除浮动的方法，它的原理是在浮动元素的后面添加一个空元素，并将其清除浮动。代码示例如下：

```html
<div class="clearfix">
  <div class="float-left"></div>
  <div class="float-left"></div>
  <div class="clear"></div>
</div>

<style>
.clearfix:after {
  content: "";
  display: block;
  clear: both;
}
.float-left {
  float: left;
}
</style>
```



在这个例子中，我们在 `.clearfix` 元素的最后添加了一个空的 `<div>` 元素，并将其清除浮动。这个空元素的样式设置为 `clear: both;`，这样它就会把前面的浮动元素清除掉。

1. 使用父元素清除浮动

这种方法的原理是给浮动元素的父元素添加样式 `overflow: hidden;` 或 `overflow: auto;`，这样父元素就会包含浮动元素，并自动清除浮动。代码示例如下：



```html
<div class="parent">
  <div class="float-left"></div>
  <div class="float-left"></div>
</div>

<style>
.parent {
  overflow: hidden;
}
.float-left {
  float: left;
}
</style>
```

在这个例子中，我们给 `.parent` 元素添加了样式 `overflow: hidden;`，这样它就会自动包含浮动元素并清除浮动。

1. 使用 CSS 伪元素清除浮动

这种方法的原理是使用 `::after` 伪元素来清除浮动。代码示例如下：

```html
<div class="clearfix">
  <div class="float-left"></div>
  <div class="float-left"></div>
</div>

<style>
.clearfix::after {
  content: "";
  display: block;
  clear: both;
}
.float-left {
  float: left;
}
</style>
```

在这个例子中，我们给 `.clearfix` 元素添加了 `::after` 伪元素，并将其清除浮动。这样，我们就不需要添加额外的 HTML 元素来清除浮动了。

需要注意的是，以上方法都有其适用的场景和局限性，需要根据实际情况选择合适的方法。

#### 57.canvas

`<canvas>` 是 HTML5 中新增的标签，它提供了一种通过 JavaScript 来绘制图形的方式，可以用于创建动画、游戏、数据可视化等各种交互式应用程序。

`<canvas>` 标签本身并不具有绘图能力，它只是图形容器，需要使用 JavaScript 来控制绘图。在 `<canvas>` 中，我们可以通过 JavaScript 来绘制各种形状、线条、文本、图像等。

以下是一个简单的使用 `<canvas>` 绘制图形的例子：

```html
<canvas id="myCanvas" width="200" height="200"></canvas>
```

```js
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

ctx.fillStyle = 'red';
ctx.fillRect(50, 50, 100, 100);
```

这个例子使用了 `getContext('2d')` 方法来获取 2D 绘图上下文，然后使用 `fillRect()` 方法来绘制一个红色矩形。其中，`fillStyle` 属性用于设置填充颜色，`fillRect()` 方法用于绘制矩形，它接受四个参数：矩形的左上角 x 坐标、y 坐标、宽度和高度。

除了 `fillRect()` 方法，还有许多其他的绘图方法，例如：

- `strokeRect()`：绘制一个矩形的轮廓线条；
- `clearRect()`：清除指定矩形区域内的所有像素；
- `fillText()`：在画布上绘制文本；
- `drawImage()`：在画布上绘制图像。

此外，我们还可以使用路径来绘制更复杂的形状，例如：

```js
ctx.beginPath();
ctx.moveTo(50, 50);
ctx.lineTo(150, 50);
ctx.lineTo(100, 150);
ctx.closePath();
ctx.stroke();
```

这个例子使用了 `beginPath()` 方法来开始一条新路径，然后使用 `moveTo()` 方法来移动画笔到指定位置，使用 `lineTo()` 方法来绘制一条线段，最后使用 `closePath()` 方法来闭合路径，并使用 `stroke()` 方法来绘制线条。

除了基本的绘图方法之外，我们还可以使用第三方库或框架来简化绘图工作，例如 D3.js、Three.js 等。
#### 58.虚拟DOM的好处

虚拟DOM（Virtual DOM）是一种JavaScript对象，它是对真实DOM的一种抽象表示。在React等一些现代JavaScript框架中，使用虚拟DOM来管理应用程序的状态和UI更新，从而提高应用程序的性能和可维护性。

虚拟DOM的好处包括：

1. **提高性能**：虚拟DOM可以通过批量更新和优化DOM操作来减少浏览器的重绘和回流，从而提高应用程序的性能。
2. **提高可维护性**：使用虚拟DOM可以将UI和状态分离，从而使代码更易于理解和维护。虚拟DOM还可以帮助开发人员更轻松地实现组件化开发，使代码更易于重用和扩展。
3. **跨平台支持**：虚拟DOM可以在不同的平台上运行，例如浏览器、服务器和移动设备等。这使得开发人员可以在不同的环境中使用相同的代码，从而提高开发效率和代码重用性。

总之，虚拟DOM是现代JavaScript应用程序开发中的一项重要技术，它可以提高性能、可维护性和跨平台支持。

#### 59.为什么vue的key不推荐使用index

在Vue中，使用v-for指令来渲染列表时，每个被渲染的元素都需要有一个唯一的key属性。这个key属性的作用是帮助Vue识别每个列表项的唯一性，从而更好地管理和更新列表。

如果使用index作为key属性，会有以下坏处：

1. **性能问题**：如果使用index作为key属性，当列表项的顺序发生变化时，Vue会强制重新渲染整个列表，这会导致性能问题，尤其是在大型列表中。
2. **状态管理问题**：如果使用index作为key属性，当列表项的顺序发生变化时，Vue可能会出现状态管理问题，例如列表项的状态可能会与其实际对应的数据不一致。
3. **可维护性问题**：如果使用index作为key属性，当需要修改列表项时，可能会导致key属性的变化，从而影响Vue的更新和管理。

因此，Vue官方不推荐使用index作为key属性，而是建议使用每个列表项的唯一标识符作为key属性，例如ID或其他唯一的属性。这样可以避免上述问题，并提高应用程序的性能和可维护性。

#### 60.require和import的区别

`require`和`import`都是用于在JavaScript中导入模块的关键字，但是它们有以下区别：

1. **语法不同**：`require`是CommonJS规范中定义的导入模块的方式，使用`require`时需要使用`module.exports`或`exports`导出模块。而`import`是ES6中定义的导入模块的方式，使用`import`时需要使用`export`导出模块。
2. **执行时机不同**：`require`是在运行时（runtime）执行的，而`import`是在编译时（compile-time）执行的。这意味着`require`可以在代码的任何位置使用，而`import`必须在文件的顶部使用，不能在代码块中使用。
3. **模块解析方式不同**：`require`使用的是同步的模块加载方式，它会阻塞代码的执行，直到模块加载完成。而`import`使用的是异步的模块加载方式，它不会阻塞代码的执行，而是在需要时动态地加载模块。
4. **支持的环境不同**：`require`是Node.js中的一个模块加载器，它只能在Node.js环境中使用。而`import`是ES6中定义的模块加载方式，它可以在支持ES6模块的现代浏览器中使用，也可以通过Babel等工具在Node.js环境中使用。

总之，`require`和`import`都是用于导入模块的关键字，但是它们的语法、执行时机、模块解析方式和支持的环境等方面都有所不同。在选择使用哪个关键字时，需要根据应用程序的需求和运行环境来决定。

#### 61.切换主题色

使用CSS预处理器是一种常用的方法，它可以让我们更加方便地定义和管理主题色变量。下面是使用Sass预处理器实现主题色切换的一个示例：

1. **定义主题色变量**：在Sass中，可以使用`$`符号来定义变量。因此，我们可以定义一组主题色变量，例如：

```scss
$primary-color: #2196f3;
$secondary-color: #f44336;
```

1. **使用变量**：在样式表中，可以使用变量来控制主题色的样式。例如，可以使用`$primary-color`变量来引用主题色变量，从而控制主题色的样式。

```scss
.button {
  background-color: $primary-color;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
}
```

1. **切换主题色**：在Vue组件中，可以通过监听用户的操作来切换主题色。当用户进行操作时，可以通过修改Sass变量的值来实现主题色的切换。

```js
// 切换主题色
methods: {
  changeThemeColor(color) {
    this.$root.$set(this.$root.$data, 'primaryColor', color)
  }
}
```

在上述代码中，通过调用`changeThemeColor`方法来切换主题色。该方法会通过`$set`方法来修改Vue根实例的`primaryColor`属性的值，从而修改Sass变量的值，从而实现切换主题色的效果。

总之，使用CSS预处理器可以让我们更加方便地定义和管理主题色变量，并且可以通过修改预处理器变量的值来实现主题色的切换。

#### 62.vue2模板使用css变量

```vue
<template>
  <!-- 如果要该组件都可以使用，则必须放置在根元素下 -->
  <div class="hello" :style="styleVar">
    <div class="child-1">I am Child 1</div>
    <div class="child-2">I am Child 2</div>
    <div @click="onClick">Change Red TO Blue</div>
  </div>
</template>

<script>
export default {
  name: "HelloWorld",
  props: {
    msg: String,
  },
  data() {
    return {
      styleVar: {
        "--colorBlue": "blue",
        "--colorRed": "red",
        "--fontSize": "30px",
        "--fontSizeTest": "30px",
      },
    };
  },
  methods: {
    onClick() {
      this.styleVar["--fontSizeTest"] = "40px";
    },
  },
};
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
.child-1 {
  color: var(--colorBlue);
  font-size: var(--fontSize);
}
.child-2 {
  color: var(--colorRed);
  font-size: var(--fontSizeTest);
}
</style>

```

#### 63.创建对象的方法

在 JavaScript 中，创建对象的方法有以下几种：

1. 对象字面量（Object Literal）：使用花括号 {} 创建一个对象，可以直接在花括号中添加属性和方法。

2. 构造函数（Constructor）：使用构造函数创建一个对象，可以通过 new 关键字来调用构造函数，创建一个新的实例对象。可以在构造函数中使用 this 关键字来定义对象的属性和方法。

3. Object.create() 方法：使用 Object.create() 方法创建一个新对象，可以指定该对象的原型对象，从而继承原型对象的属性和方法。

4. ES6 中新增的 class 关键字：使用 class 关键字定义一个类，通过 new 关键字创建一个新的实例对象。可以在类中使用 constructor 方法来定义对象的属性和方法。

以上这些方法都可以用来创建 JavaScript 对象，具体使用哪种方法取决于你的需求和习惯。

好的，下面分别举一个例子：

1. 对象字面量（Object Literal）：

```js
const person = {
  name: 'Alice',
  age: 25,
  sayHello: function() {
    console.log(`Hello, my name is ${this.name}.`);
  }
};
```

2. 构造函数（Constructor）：

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHello = function() {
    console.log(`Hello, my name is ${this.name}.`);
  };
}

const person = new Person('Alice', 25);
```

3. Object.create() 方法：

```js
const personPrototype = {
  sayHello: function() {
    console.log(`Hello, my name is ${this.name}.`);
  }
};

const person = Object.create(personPrototype);
person.name = 'Alice';
person.age = 25;
```

4. ES6 中新增的 class 关键字：

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

const person = new Person('Alice', 25);
```

#### 64.遍历获得对象的属性

##### 1.可以使用`for...in`循环来遍历对象的属性，包括**<u>*继承*</u>**的属性。示例代码如下：

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.sayName = function() {
  console.log(this.name);
}

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

const myDog = new Dog('Buddy', 'Golden Retriever');

for (let key in myDog) {
  console.log(key + ': ' + myDog[key]);
}
```

在上述代码中，我们定义了一个`Animal`构造函数和一个`Dog`构造函数，`Dog`继承了`Animal`的属性和方法。然后创建了一个`myDog`实例，使用`for...in`循环遍历了该实例的所有属性，包括继承的属性。输出结果如下：

```js
name: Buddy
breed: Golden Retriever
sayName: function() {
  console.log(this.name);
}
```

可以看到，`for...in`循环遍历了`myDog`实例的`name`和`breed`属性，以及`Animal.prototype`中的`sayName`方法。

##### 2.不包括继承的属性

在JavaScript中，获取对象属性不包括继承的属性可以使用`Object.keys()`方法。这个方法会返回一个数组，包含对象自身的所有可枚举属性的名称。

例如，假设我们有一个对象`person`：

```js
const person = {
  name: 'John',
  age: 30,
  gender: 'male'
};
```

我们可以使用`Object.keys()`方法获取`person`对象自身的所有属性名：

```js
const keys = Object.keys(person);
console.log(keys); // ['name', 'age', 'gender']
```

需要注意的是，`Object.keys()`方法只会返回对象自身的可枚举属性，不会返回继承的属性。如果需要获取对象自身的所有属性，包括不可枚举属性和Symbol类型的属性，可以使用`Object.getOwnPropertyNames()`方法。




### 算法

#### 1.计算数组的交集、并集、差集

对于两个一维数组，可以使用JavaScript中的一些方法来求它们的交集、并集和差集。

假设有两个数组arr1和arr2，可以按照以下方式求它们的交集、并集和差集：

1. 求交集

交集即为两个数组中都存在的元素，可以使用filter方法和includes方法来实现：

```javascript
const intersection = arr1.filter(item => arr2.includes(item));
```

2. 求并集

并集即为两个数组中所有的元素，可以使用concat方法和Set数据结构来实现：

```javascript
const union = Array.from(new Set(arr1.concat(arr2)));
```

3. 求差集

差集即为在arr1中存在，但在arr2中不存在的元素，可以使用filter方法和includes方法来实现：

```javascript
const difference = arr1.filter(item => !arr2.includes(item));
```

以上方法都是基于ES6的语法来实现的，如果需要兼容更早的浏览器，可以使用一些ES5的方法来实现。

#### 2.数组拍平
- ES6中，可以使用扩展运算符（spread operator）和Array.flat()方法来实现数组的拍平。具体来说，使用扩展运算符可以将多维数组展开成一维数组，而Array.flat()方法可以将多维数组拍平成指定深度的一维数组。

例如，假设有一个二维数组arr，可以使用扩展运算符将其展开成一维数组，如下所示：

```js
const arr = [[1, 2], [3, 4], [5, 6]];
const flatArr = [...arr.flat()];
console.log(flatArr); // [1, 2, 3, 4, 5, 6]
```

另外，Array.flat()方法可以指定拍平的深度，例如：

```js
const arr = [[[1, 2]], [[3, 4]], [[5, 6]]];
const flatArr = arr.flat(2);
console.log(flatArr); // [1, 2, 3, 4, 5, 6]
```

在上面的例子中，arr是一个三维数组，使用flat(2)方法将其拍平成深度为2的一维数组。


- 可以使用递归来实现数组拍平，可以尝试以下代码：

```javascript
function flatten(arr) {
  return arr.reduce(function (prev, next) {
    return prev.concat(Array.isArray(next) ? flatten(next) : next);
  }, []);
}
```

这个函数接收一个数组作为参数，然后使用 reduce 方法来遍历数组中的每一个元素。如果当前元素是一个数组，就递归调用 flatten 函数，否则就将当前元素加入到结果数组中。最终返回拍平后的数组。

#### 3.数组排序







### css相关

#### 1.transform 

- translate：用于平移元素，可以接受一个或两个参数，分别表示水平和垂直方向上的平移距离。
- translateX：用于水平方向上的平移，接受一个参数，表示水平方向上的平移距离。
- translateY：用于垂直方向上的平移，接受一个参数，表示垂直方向上的平移距离。
- scale：用于缩放元素，可以接受一个或两个参数，分别表示水平和垂直方向上的缩放比例。
- scaleX：用于水平方向上的缩放，接受一个参数，表示水平方向上的缩放比例。
- scaleY：用于垂直方向上的缩放，接受一个参数，表示垂直方向上的缩放比例。
- rotate：用于旋转元素，接受一个参数，表示旋转角度，单位为度数。
- skew：用于倾斜元素，可以接受一个或两个参数，分别表示水平和垂直方向上的倾斜角度，单位为度数。
- skewX：用于水平方向上的倾斜，接受一个参数，表示水平方向上的倾斜角度，单位为度数。
- skewY：用于垂直方向上的倾斜，接受一个参数，表示垂直方向上的倾斜角度，单位为度数。
- matrix：用于在任意方向上进行变换，接受六个参数，分别表示变换矩阵的六个值。
- matrix3d：用于在三维空间中进行变换，接受 16 个参数，分别表示变换矩阵的 16 个值。

需要注意的是，transform 属性只会影响元素的视觉呈现，不会改变元素的实际位置和大小。

#### 2.transtion

下面是 CSS 中 transition 属性的全部属性列表：

- transition-property：指定要过渡的 CSS 属性名称，可以是一个或多个。
- transition-duration：指定过渡的持续时间，单位为秒或毫秒。
- transition-timing-function：指定过渡的时间函数，用于控制过渡的速度变化。
- transition-delay：指定过渡的延迟时间，单位为秒或毫秒。

需要注意的是，transition 属性可以同时指定多个过渡效果，每个过渡效果之间用逗号隔开。例如：

```css
transition: width 1s ease, color 2s linear;
```

这个例子中，元素的宽度和颜色都会发生过渡效果，宽度的过渡持续时间为 1 秒，时间函数为 ease，颜色的过渡持续时间为 2 秒，时间函数为 linear。

在 CSS 中，`ease` 和 `linear` 是 CSS transition 中的两种过渡函数，用于指定元素从开始状态到结束状态的过渡方式。

`ease` 是指元素在开始和结束时会慢慢加速和减速，中间时会达到最大速度的一种过渡方式，它会让元素的过渡看起来更加自然、流畅。

`linear` 则是指元素在整个过渡过程中保持匀速运动，没有加速和减速的过渡方式，它会让元素的过渡看起来更加简单、直接。

可以将两种过渡函数看作是不同的过渡方式，可以根据具体的需求选择使用哪种过渡函数来实现不同的过渡效果。







## 还没掌握的

### 1.作用域插槽

### 2.canvas

### 3.webpack

### 4.class语法

### 5.render函数